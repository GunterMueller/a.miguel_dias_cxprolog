####################
CxProlog User Manual
####################

:Author: A\. Miguel Dias
:Date: 11 Apr 2005
:Version: 0.90 (release 5)
:Affiliation:
    CITI - Centro de Informatica e Tecnologias da Informacao
    Dept. de Informatica, FCT, Universidade Nova de Lisboa.
    Copyright (C) 1993-2004 A.Miguel Dias, CITI, DI/FCT/UNL

:License:
    CxProlog is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 1, or (at your option)
    any later version.

    CxProlog is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with CxProlog; see the file COPYING.  If not, write to
    the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

:About this file:
    This file was prepared as input to the program reStructuredText, a
    a processor of plaintext documentation that knows how to generate such
    formats as HTML, XML oe TeX. reStructuredText is a component of the
    documentation preparation system DocUtils, which is available
    at http://docutils.sourceforge.net.

Index:

- Introduction
- CxProlog Limits
- CxProlog Builtin Predicates

    - Misc
    - Control
    - Terms
    - Comparing Terms
    - Arithmetic
    - Units/Contexts
    - Program Database
    - Operators
    - Input/Output - Text File Streams
    - Input/Output - Dec-10 Prolog Compatibility Text Streams
    - Input/Output - Binary File Streams
    - Input/Output - Buffer Streams
    - Input/Output - Null Streams
    - OS Services
    - File System
    - Flags
    - Imperative Variables (ivars)
    - Imperative Queues
    - Imperative Stacks
    - Imperative Dictionaries
    - Imperative Arrays
    - Imperative Buffers
    - Handling Transient Text
    - Threads (coroutines)
    - Sockets
    - Processes
    - Debugger
    - External Interface with Java

- Customising CxProlog

    - Alternative Boot Files
    - Default Boot
    - Adding Builtin Predicates Written In C

- Overview of the Debugger

    - Introduction
    - Debugging Line
    - Debugging Commands

- Writing CxProlog scripts for Unix
- Testing CxProlog


Introduction
============

CxProlog is a WAM based Prolog system, extended with some features:

- Threads (Modula-2-like coroutines);
- Units (Modula-2-like modules)
- Contexts (cf. [L.Monteiro, A.Porto: "Contextual Logic Programming",
  in Proc. 6 ICLP, Lisboa, Portugal, MIT Press, 1989])
- Imperative mechanisms:

    - imperative variables (ivars),
    - imperative queues,
    - imperative stacks,
    - imperative dictionaries,
    - imperative arrays,
    - buffers.

- Exception mechanism
- Interactive debugger
- Java interface
- ISO 10646 Unicode support

CxProlog is small and manageable, yet reasonably fast.

CxProlog is a compiler but provides an interpreter-like interface.

CxProlog is written in C. CxProlog was tested on several
Linux machines using the gcc compiler: i386, R6000, Mips,
on Windows using the DJGPP gcc compiler, and on the Classic Macintosh using
the THINKC 5.0 compiler and the MPW development system.
It should be compatible with any 32 or 64 bit machine with at least
3 bits available for tags in the data addresses. No customisation of
the source code is necessary, as CxProlog adjusts itself to the
machine where it runs.

The main builtin predicates of CxProlog are those described in
"Introduction to Logic Programming" by Clocksin, Springer Verlag.

CxProlog system is experimental software. As yet, there is no support
and this "MANUAL" file is the sole documentation available.

Contributors with some ideas for improving CxProlog:
Antonio Porto, Tiago Antao, Rui Marques,
Paulo Matos, Nuno Soares, Ricardo Amador,
Joaquim Baptista

Artur Miguel Dias (amd@di.fct.unl.pt)
CITI - Centro de Informatica e Tecnologias da Informacao
Dept. de Informatica, FCT, Universidade Nova de Lisboa
Portugal


CxProlog Limits
===============

- Code Area: No limit (grows as necessary)
- Local Stack + Global Stack: No limit (grows as necessary)
- Trail: No limit (grows as necessary)
- Max arity of functor or predicate: 64
- Max number of distinct variables in term: No limit
- Max number of distinct variables in asserted clause: 64
- Max length of atom: No limit
- Max number of clauses per predicate: No limit
- Max code length of compiled clause: No limit
- Max number of simultaneously open streams: this is OS dependent
- Max int: 268435455 = 2^28-1  (2^60-1 on 64 bit machines)
- Min int: -268435456 = -2^28  (-2^60 on 64 bit machines)
- Max Unicode char code: 268435455 = 2^28-1  (2^31-1 on 64 bit machines)


CxProlog Builtin Predicates
===========================

This section describes the CxProlog builtin predicates. The builtin
predicates are special because:

- they are predefined;
- they are visible to all the units;
- they are usually immutable;
- they are untraceable by the builtin debugger;

In this document, each builtin is introduced using a generic goal
template, followed by a condensed description of its semantics.  As
an example, the goal template corresponding to the builtin predicate
*functor/3* is:

    *functor(?T,?A,?N)*

In a goal template, the symbols preceding the parameters have the
following interpretation:

    \+
       Input parameter. The actual argument instantiates the parameter.

    \-
       Output parameter. The actual argument is matched against the
       parameter.

    \?
       Input/Output parameter. The actual argument can be used both ways.

Also, in a goal template, the name of the parameters reflect
their type, according to the following table:

    A
        atom
    B
        buffer (special datatype)
    D
        dictionary or array (special datatypes)
    F
        filename (atom)
    G
        goal to be proved
    K
        stack (special datatype)
    L
        list
    N
        number (integer, float, or Unicode char code)
    P
        process (special datatype, only available in Unix)
    Q
        queue (special datatype)
    S
        stream (special datatype)
    T
        general term
    U
        unit designator (term)
    Z
        thread (special datatype)

The sophisticated user can add extra builtin predicates and redefine
existing predefined builtin predicates. The section _`Customizing CxProlog`
explains how this is done.

Most of the CxProlog builtin predicates conform to:

- Clocksin: "Introduction to Logic Programming", Springer Verlag.
- L.Monteiro, A.Porto: "Contextual Logic Programming",
  in Proc. 6 ICLP, Lisboa, Portugal, MIT Press, 1989.

Misc
~~~~

version(-A)
    Gets the identification of the running version of CxProlog.

version
    Show the identification of the current version
    of CxProlog.

show
    Synopsis of the available "show predicates", which
    are predicates that show certain details of
    the CxProlog internal state.

host_speed(-N)
    Evaluates the speed of the host machine. Faster
    machines produce larger numbers. The result is always larger than 0.
    Examples:

    - MacPlus --> 2;
    - Celeron/433 --> 450.
    - PentiumIII-M/700 --> 900.

    Of course the result provides only a rough indication. Also the result
    may vary somewhat with the version of CxProlog being used.

Control
~~~~~~~
\+G1,+G2
    Conjunction. Proves G1 and G2.

\+G1;+G2
    Disjunction. Proves G1 or G2.

\!
    Cut. When encountered as a goal, it commits the
    predicate where it occurs to the choices made
    since that predicate was last activated. Note that
    there is special support for the cut occurring in the
    context of goals with the following main functors:

      call/1, not/1, +/1, ->/2, ;/2, ,/2, <>/2, >>/2,
      >/1, </1, try/1, once/2, possible/2, gen/2,
      call_on_empty_context/1, with_ivar/3.

    Only "compiled cuts" work. For example, the goal
    *X=!, call(X)* generates the following runtime error:
    *{ERROR (!/0): Dynamic '!/0' is not supported.}*

call(+G)
    Proves goal G.

call(+A,+L)
    Defined as *call(A,L) :- X =.. [A|L], X*.

\+G
    Same as call(+G).

not +G
    Goal G is not provable (that is G fails).

\\+ +G
    Same as *not G*.

try +G
    Always succeeds deterministically, either with the first
    solution for G, if one exists, or otherwise with G
    unchanged. Except for the occurrence of cuts in G,
    this predicate could be defined as:
    *try G :- G, ! ; true.*

once +G
    Succeeds deterministically with the first solution to G
    if and only if there exists at least one. Except for
    the occurrence of cuts in G, this predicate could be
    defined as:
    *once G :- G, !.*

possible +G
    Succeeds deterministically if and only if there is at
    least one solution to G. The current instantiation
    state of G is not changed. Except for occurrence of
    cuts in G, the predicate could be defined as:
    *possible G :- not not G.*

gen +G
    Explores all the alternatives in the goal G and, at
    the end, succeeds with the current instantiation
    state of G unchanged. Except for occurrence of cuts
    in G, this predicate could be defined as:
    *gen G :- G, fail ; true.*

\+G1->+G2;+G3
    Conditional goal. If G1 succeeds prove G2; if not,
    prove G3.

\+G1->+G2
    Same as (G1->G2;false). But if the 'compatible_if_then'
    flag is 'off', it becomes equivalent to *(G1->G2;true)*
    which is more sound logically.

true
    Succeeds.

fail
    Fails.

false
    Same as fail.

repeat
    Succeeds repeatedly on backtracking.

repeat(+N)
    Succeeds repeatedly on backtracking exactly N times.
    After that fails.

repeat(+N1,-N2)
    Like repeat(N1) and the succession 1, 2, 3, ..., N1
    is generated via N2 on backtracking.

restart
    Restarts CxProlog execution. The execution stacks are
    cleared, but the internal database remains unchanged.

abort
    Same as restart/0.

halt
    Terminates CxProlog execution displaying the message
    "CxProlog halted".

exit
    Exits from CxProlog, displaying no message.

question(+G,+L)
    Implements the top-level queries of the predefined
    top-level user-iteration. Also implements the *?-G*
    questions inside the consult/reconsult predicates.

findall(+T,+G,-L)
    L is unified with the list (not ordered an possibly
    containing duplicates) of all the instances of template
    T for which G is provable. All free variable
    (those contained in G and not in T) are considered
    to be existentially quantified.

bagof(+T,+G,-L)
    L is unified with the list (not ordered an possibly
    containing duplicates) of all the instances of template
    T for which G is provable. The predicate fails if G
    fails for every instance of T. If G is of the form
    *X^T*, where X is a variable, then X is treated as being
    existentially quantified in T. G must not be an
    uninstantiated variable.

setof(+T,+G,-L)
    Like bagof except that the returned list L is free from
    duplicates.

catch(+ProtectedGoal,-Exception,-HandlerGoal)
    This is equivalent to ProtectedGoal, unless an exception
    is thrown while ProtectedGoal is being proved. In this
    case all the bindings made by ProtectedGoal are undone,
    like it the goal has failed, and Exception is unified with
    the term representing the exception. If the unification
    succeeds, the exception is said to have been "caught"
    and the HandlerGoal is executed, in fact replacing the
    execution of the original ProtectedGoal. If the unification
    fails, the system starts looking for an ancestor of the
    current goal that would handle the exception. If it
    cannot find any such a handler, the system activates
    a default handler that prints the exception term and,
    if the debugger is on, also prints the stack trace
    corresponding to the execution context at the point
    where the exception was raised.

catch(+ProtectedGoal,-Exception,-StackTrace,+HandlerGoal)
    Similar to catch/3 except that, if the debugger is on,
    a stack trace of the current execution environment
    is built and returned in the parameter StackTrace.
    If the debugger is off the empty list is returned.

throw(+ExceptionTerm)
    Explicitly throws an exception. ExceptionTerm can be any
    term except a free variable.

    **Note:** All non-fatal errors that might arise during the
    execution of programs manifest themselves by throwing
    exceptions.

on_exception(?Pattern,+ProtectedGoal,+HandlerGoal)
    This is a Quintus-Prolog compatibility predicate.
    Equivalent to
    *catch(+ProtectedGoal,?Pattern,+HandlerGoal).*
    Note the different argument order.

raise_exception(+Exception)
    This is a Quintus-Prolog compatibility predicate.
    Identical to throw/1.

Terms
~~~~~

var(+T)
    T is an uninstantiated variable.

nonvar(+T)
    T is an instantiated term.

atom(+T)
    T is an atom.

integer(+T)
    T is an integer number.

float(+T)
    T is a float number.

number(+T)
    T is a number (integer or float).

atomic(+T)
    T is an atom or a number.

functor(?T,?A,?N)
    T is a term with name A and arity N.

arg(+N,+T,-Tn)
    Tn in the N-th argument of term T. The condition 1 <= N <= arity(T)
    must hold or the predicate fails.

ins(+N,?T,?X,?TX)
    Term TX is the term T with the extra argument X
    inserted at position N. The condition 1 <= N <= arity(T)+1
    must hold or the predicate fails. Bidirectional predicate.

ins_start(+T,+X,-TX)
    Term TX is the term T with the extra argument X
    inserted at the start position. Efficient
    unidirectional predicate.

ins_end(+T,+X,-TX)
    Term TX is the term T with the extra argument X
    inserted at the end position. Efficient
    unidirectional predicate.

?T =.. ?L
    Univ. L is the list whose head is the atom
    corresponding to the principal functor of T and
    whose tail is the list of arguments of T.

name(?AN,?L)
    L is the list of Unicode char codes that makes up the printed
    representation of the atom or number AN.

atom_codes(?A, ?L)
    L is the list of Unicode char codes that makes up the printed
    representation of the atom A.

number_codes(?N,?L)
    L is the list of Unicode char codes that makes up the printed
    representation of the number N.

numbervars(+T,+Na,-Nz)
    Unifies the variables in T to terms of the form
    '$VAR'(N), with N between Na and Nz-1.

free_vars(+T,-L)
    L is the list of all the free variables in term T.

subterm(+T1,-T2)
    T1 is a part of T2.

+T1 = +T2
    Unifies T1 with T2.

+T1 \\= +T2
    T1 is not unifiable with T2.

copy_term(+T1,-T2)
    T2 is a copy of term T1 in which all variables have
    been replaced by new variables occurring nowhere
    else.

copy_term(L,+T1,-T2)
    T2 is a copy of term T1 in which all variables in
    list L have been replaced by new variables
    occurring nowhere else. Example:
    *copy_term([X,Y],f(A,X,Y),Z) --> Z=f(A,_45,_46).*

quote(+A1,-A2)
    Quotes a piece of text.

atom_term(?A,?T)
    Converts between a term T and its textual
    representation A.

atom_termq(?A,?T)
    Variant of *atom_term(A,T)* which quotes atoms where
    necessary so that the conversion is reversible.

unique(-A)
    Generates unique atoms, from '$%0' to '$%u4294967295'.

app(?L1,?L2,?L3)
    Append lists.

add_pl(+A1,-A2)
    A2 is the concatenation of A1 with '.pl' unless this
    extension is already in A1. Another exception is
    the atom 'user', which remains unchanged.

atoms
    Shows information concerning the CxProlog hash table
    of atoms.

floats
    Shows information concerning the CxProlog hash table
    of very large precision floats.

Comparing Terms
~~~~~~~~~~~~~~~
A total ordering, called "standard order" and denoted by @<, is defined
over the set of all Prolog terms. Most predicates in this section are
concerned with this ordering.


+T1 == +T2
    T1 and T2 are literally identical.

+T1 \\== +T2
    T1 and T2 are not literally identical.

+T1 @< +T2
    T1 is before T2 in the standard order.

+T1 @> +T2
    T1 is before T2 in the standard order.

+T1 @=< +T2
    T1 is not after T2 in the standard order.

+T1 @>= +T2
    T1 is not before T2 in the standard order.

sort(+L1,-L2)
    Quicksorts list L1 into L2. Duplicates are removed.

msort(+L1,-L2)
    Quicksorts list L1 into L2.

keysort(+L1,-L2)
    Quicksorts list L1 into L2. Items of L1 must have
    the form Key-Value.

Arithmetic
~~~~~~~~~~
These are the predicates that deal with the evaluation of arithmetic
expressions. At the time of evaluation, each logic variable in an
arithmetic expression is expected to be bound to some number or to
some arithmetic expression.


-N is +Exp
    Evaluates Exp as an arithmetic expression and unifies
    the result with N. The result of the evaluation is
    automatically converted to an integral value
    whenever its decimal part is zero or almost zero.

+T1 =:= +T2
    T1 and T2 evaluate to the same number.

+T1 =\\= +T2
    T1 and T2 do not evaluate to the same number.

+T1 < +T2
    The value of T1 is lesser than the value of T2.

+T1 > +T2
    The value of T1 is greater than the value of T2.

+T1 =< +T2
    The value of T1 is not greater than the value of T2.

+T1 >= +T2
    The value of T1 is not less than the value of T2.

succ(?N1,?N2)
    The non-negative integer N2 is the successor of the
    non-negative integer N1.

The syntax of the arithmetic expressions (*Exp*) is:

    ===========     ==========      ===========    ==========
    cputime         heapused        pi             inf
    max_int         min_int         int_size       float_size
    Exp + Exp       Exp - Exp       \- Exp         nan
    Exp * Exp       Exp / Exp       Exp mod Exp    Exp ^ Exp
    sqrt(Exp)       exp(Exp)        log(Exp)       log10(Exp)
    Exp >> Exp      Exp << Exp      Exp // Exp     Exp /\\ Exp
    Exp \\/ Exp     \\ Exp          ceil(Exp)      floor(Exp)
    round(Exp)      sin(Exp)        cos(Exp)       tan(Exp)
    asin(Exp)       acos(Exp)       atan(Exp)      [Exp]
    ===========     ==========      ===========    ==========

floor(X)
    Largest integral value not greater than X

ceil(X)
    Smallest integral value not less than X

round(X)
    Round X to the nearest integer, away from zero.

inf
    The IEEE 754 float constant "infinity". Here are some properties of inf:

    - inf =:= inf  inf is equal to itself
    - N < inf      for any number N except inf
    - -inf < N     for any number N except -inf
    - 1 / inf      yields 0
    - 1 / 0        yields inf
    - -1 / 0       yields -inf
    - inf / 0      yields inf
    - inf + 1      yields inf
    - inf * inf    yields inf
    - log(0)       yields -inf.

nan
    The IEEE 754 float constant "not a number". Here are some properties of nan:

    - nan =\\= nan nan is not equal to itself
    - log(-1)      yields nan
    - inf / inf    yields nan
    - inf - inf    yields nan

[Exp]
    Allowed only if the flag 'compatible_strings' is 'on'. For
    example *"a" =:= [97].*

Units/Contexts
~~~~~~~~~~~~~~
In CxProlog, every goal is proved in relation to a *current context*, which
is a stack of unit designators. We call *current unit* the unit designated
by the unit designator at the top of the current context. There is no
current unit when the current context is empty. An extra *historic context*
where entire contexts can be pushed was included for further flexibility.

When a predicate is invoked and, in the current unit, there is no matching
local nor imported definition available, the units below the current unit
are sequentially searched, from top to bottom. If a suitable visible
definition is found then the execution of the predicate proceeds in the
smaller context that results from the initial one by removing all the
unsuccessfully searched units. Otherwise the predicate fails (and produces
an warning if the flag 'undef_warnings' is 'on').


+U>>+G
    Context extension. Proves G in the current context
    extended with the unit designator U.

+U<>+G
    Context switching. Proves G with the top of the
    current context replaced by the unit designator U.

call_on_empty_context(+G)
    Context freeing. Proves G in the empty context.

call_on_context(+L,+G)
    Context setting. Proves G in a given context L,
    represented as a list of unit designators.

down +G
    Context down. Proves G with the top of the
    current context popped.

context(-L)
    L is the current context, represented as a list of
    unit designators.

show_context
    Displays the current context on the current output
    stream.

show_context(+S)
    Displays the current context on the output stream S.

>+G
    Context saving. Proves G in the current context,
    after pushing the current context on the historic
    context.

<+G
    Context restoring. Proves G in the most recently
    saved context, which is temporarily popped from
    the historic stack.

hcontext(-L)
    L is the current historic context, represented as a
    list of lists of unit designators.

show_hcontext
    Displays the current historic context on the current
    output stream.

show_hcontext(+S)
    Displays the current historic context on the output
    stream S.

create_unit(+USpec)
    Creates a new unit, as specified by unit specifier USpec.

context_top(-U)
    U is the top of the current context. This is a
    unit designator corresponding to the current unit.

unit_spec(-USpec)
    USpec is the unit specifier of the current unit.

unit_param(+N,-T)
    T is the value of the N-th parameter of the current unit.

unit_arity(-N)
    N is the arity of the current unit.

current_unit(-T)
    Generates, through backtracking, the descriptors of
    all the existing units.

units
    Shows all the existing units.


check_imports
    Produces warnings concerning the inconsistency of
    the import/visibility declarations. Examples:

    - "Predicate A/N is imported from non-existent unit U".
    - "Imported predicate A/N is not visible in unit U".

check_missing
    Produces warnings concerning missing predicates,
    invoked in existing code. Sometimes they will be
    legitimate "context dependent predicates".
    Sometimes they will be genuine mistakes that must
    be corrected.

This is a simple sampling unit definition. Notice the visibility
declarations, the import declarations and the use of a parametrized unit::

    unit a(P).
    visible [xxx/0, yyy/0, ccc/0].
    import vvv/0 from d(222).

    xxx :- show_context, writeln('xxx: I am the a/0 version').
    ccc :- show_context, xxx.
    yyy :- unit_param(1,X), writeln(X).
    zzz :- P>>context(X), writeln(X).
    s:- v := [1,2,Z].
    g(X) :- v =: X.

Program Database
~~~~~~~~~~~~~~~~
Some of these predicates allow the program to be modified while running.
Some other predicates allow information about the state of the program
to be gathered.


assert(+T)
    Clause T is asserted at the beginning of the current
    unit. This predicate invokes a fast compiler
    (written in C) that generates code for the
    CxProlog virtual machine.

asserta(+T)
    Same as assert(+T).

assertz(+T)
    Asserts the clause T at the ending of the current
    unit.

clause(+T1,-T2)
    Matches T1 and T2 with the head and body of a clause
    in the current unit. This predicate can be used to
    generate, through backtracking, all the clauses in
    the current unit.

retract(+T)
    Erases from the current unit the first clause
    matching T.

retractall(+T)
    Erases from the current unit all the clauses whose
    heads match T.

abolish(+A,+N)
    Deletes the predicate A/N from the current unit. The
    abolish/2 predicate can also be used to delete
    predicate import declarations.

abolish_builtin(+A,+N)
    Deletes the predefined builtin predicate A/N.

    **Only works at boot time.**
    This predicate is offered as a tool for the sophisticated
    user who wants to create an "ALTERNATIVE BOOT FILE".

rename_builtin(+A,+N,+Anew)
    Renames the predefined builtin predicate A/N to Anew/N.

    **Only works at boot time.**
    This predicate is offered as a tool for the sophisticated
    user who wants to create an "ALTERNATIVE BOOT FILE".

mutable_builtin(+A,+N)
    Makes the user-defined builtin predicate A/N a
    mutable predicate. The *:-mutable_builtin(A,N)*
    command must precede the definition of the mutable
    builtin predicate A/N. By default, builtins are
    immutable.

    **Only works at boot time.**
    This predicate is offered as a tool for the sophisticated
    user who wants to create an "ALTERNATIVE BOOT FILE".

current_predicate(-T)
    Generates, through backtracking, the functors of all
    predicates in the current unit.

visible_predicate(-T)
    Generates, through backtracking, the functors of all
    visible predicates in the current unit.

imported_predicate(-T,-U)
    Generates, through backtracking, the functors of all
    imported predicates in the current unit

builtin_predicate(-T)
    Generates, through backtracking, the functor of all
    the builtin predicates.

system_predicate(-T)
    Same as builtin_predicate/1.

builtins
    Shows all existing builtin predicates.


+T1 :- +T2
    Handy predicate for asserting clauses at the top
    level. Equivalent to assertz((+T1 :- +T2)).

all
    Lists the contents of all the existing units.

listing
    Lists the contents of current unit, including the
    visibility and the import declarations.

list
    Same as listing.

listing(+A)
    Lists all the predicates named A in the current unit.

listing(+A/+N)
    Lists the clauses of predicate A/N, in the current
    unit.

code Spec
    Displays the virtual machine code for all predicates
    described by Spec. Spec can be an atom, a functor
    or a list of atoms and functors.

statistics
    Shows the space currently used in the various data
    areas of CxProlog and also the running time since
    startup.

silent_consult(+F)
    Consults the file F, producing no statistics.

silent_reconsult(+F)
    Reconsults the file F, producing no statistics.

consult(+F)
    Consults the file F, writing some statistics.

reconsult(+F)
    Reconsults the file F, writing some statistics.

\[+F1,...,+Fn\]
    Shorthand for consulting or reconsulting a list of
    files. A filename Fi may optionally be preceded by
    the operator '-' to indicate that file should
    be reconsulted instead of consulted.
    Example: *[a,-b].*

consulting(-S)
    Obtains the stream being consulted or reconsulted.
    May succeed only if used in directives :-/1 or ?-/1
    that show up in the stream itself.

Operators
~~~~~~~~~
op(+Prec,+Type,+Name)
    Declares a operator named Name of type Type and
    precedence Prec. Name can be a single operator
    name or a list of operator names. Type is one of
    the following atoms: fx, fy, xf, yf, xfx, xfy, yfx,
    yfy. Prec is one integer in the range 0..1200,
    higher values indicating lower precedence. "0" is a special precedence
    that cancels one currently active interpretation of the operator:

     - the prefix interpretation of the operator if Type is fx, fy
     - the infix interpretation of the operator if Type is xfx, xfy, yfx
     - the postfix interpretation of the operator if Type is xf, yf.

current_op(-Prec,-Type,-Name)
    Provides read-only access to the internal operator table.
    Can also be used to generate, through backtracking, all
    the existing operators.

op_flag(+Name,+A,-T)
    Queries the value of operator flag A for the operator
    named Name.

op_flag(+Name,+A,-To,+Tn)
    Gets or changes the value of operator flag A for the operator
    named Name. The old value of A is To and the new value
    is Tn.

ops
    Shows details about the currently defined operators.

reset_ops
    Resets all the operators to their initial state.

Operator flags:

parenthesised
    Controls how the operator is processed by the term reader
    (predicates read/1 and read/2). If an operator with this
    flag 'on' ocurrs as principal functor of a term surrounded
    by parenthesis, as in *(TERM)*, then the resulting term
    will have the form *'$PAR'(TERM)*. DEFAULT=off.


Input/Output - Text File Streams
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
On the following predicates, S stands for a stream (a new kind of
primitive type), or for an ivar bound to a stream.

The file streams are created using open/3, closed using close/1 and processed
using get0/1, get0/2, peek0/1, peek0/2, put/1, put/2, get_line/1,
get_line/2, read/1, read/2, write/1, write/2, etc.

There are also three block oriented predicates which, being low-level,
should be used carefully : get_block/2, get_block/3 and put_block/2.
More on this later.

The predefined atoms 'user_input', 'user_output' and 'user_error' denote
the "standard input stream", "standard output stream", and "standart
output error stream". The atom 'user' represents either 'user_input'
or 'user_output', depending on the context. Note that 'user_input',
'user_output' and 'user_error' denote CONSTANT STREAMS: the meaning
of those atoms is predefined and cannot be changed.

There are also two implicit current streams: the "current input stream"
and the "current output stream". Some stream predicates operate over
the implicit streams. The implicit streams are anonymous but they can
be obtained using the predicates current_input/1, current_output/1;
and can be changed using the predicates set_input/1, set_output/1.
The initial setup of the two implicit current streams is 'user_input'
and 'user_output'.

CxProlog supports th ISO 10646 Unicode character
set (minus composing characters) and allows any Linux supported
character encoding to be associated with each text file stream.
Such association is established at opening time using
the predicate open/4, the encoding being specified
using  a Linux locale, e.g. 'en_US.iso885915', 'en_US.utf8',
'pt_PT.iso885915@euro' or 'sr_YU.iso88595@cyrillic'.
The useful "fake locale" 'text' is also allowed, standing
for the default encoding (as defined in the current locale OS
environment).

Filenames are always assumed to be in the default encoding.

In CxProlog, all text is internally represented using the compact
UTF-8 encoding. CxProlog performs automatically and
transparently all the necessary conversions between this
internal fixed encoding and the various supported external
encodings. Even filenames are automatically converted
(to the default encoding) before they are sent to the OS.

Now some final words about the three block oriented predicates:
get_block/2, get_block/3 and put_block/2. They allow a text file stream
to be processed in large chunks, or even in just one big chunk. For example,
the following predicate copy_file_in_one_go/1 implements file copying
by transfering all the data in just one big chunk::

        copy_file_in_one_go(FName,GName) :-
            buffer_new(Buff),
            open(FName,read,F), get_block(F,Buff), close(F),
            open(GName,write,G), put_block(G,Buff), close(G),
            buffer_delete(Buff).

Be carefull with the block oriented predicates because they processes data
in binary and do not attempt to do any kind of conversion whatsoever.
For instance, if you use them to copy text between two text file streams
in different encodings you will get garbage at the destination.

When applied to text streams, the block oriented predicated are useful for:

- extracting or inserting blocks of text in the middle of a stream
(as long the encodings are respected);
- extracting or inserting binary data in the middle of a stream (useful
for handling multimedia).


stream(+S)
    S is a valid active stream.

open(+F,+M,-S)
    Opens a text stream S over the file specified by F.
    The mode M is one of following atoms: 'read', 'write',
    'append'. The character encoding that becomes associated
    with the stream is the default encoding, as defined in the current
    locale Linux environment.

open(+F,+M,+E,-S)
    Similar the open/3 except that an explicit character
    encoding can be specified using an atom E. Any
    Linux supported character encoding can be used, e.g.
    'en_US.utf8' or 'pt_PT.iso885915@euro'. The atom 'text'
    can also be used, standing for the default encoding,
    as defined in the current locale Linux environment.

close(+S)
    Closes the stream S.


set_input(+S)
    Makes stream S the current input stream.

current_input(-S)
    Gets the current input stream.

read(-T)
    Reads the next term from the current input stream. At
    end-of-file, the atom 'end_of_file' is returned.
    (The names of the variables in the term T can be
    gathered using varnames/1.)

read(+S,-T)
    Reads the next term from the input stream S. At
    end-of-file, the atom 'end_of_file' is returned.
    (The names of all the vars in the term T can be
    gathered using varnames/1.)

varnames(-L)
    L is a list of pairs Var=Name, telling the names of
    all the variables in the last term returned by
    read/1, read/2 or atom_term/2.

read_with_source(+S,-T,-A)
    Similar to read/2, except that it returns in the atom A
    the exact source text that gave rise to the term.

read_tokens(-L)
    Reads an entire line of text as a list of tokens
    (token = atomic lexical element). If the line is
    empty then the empty list is returned. At
    end-of-file, the atom 'end_of_file' is returned.

read_tokens(+S,-L)
    Reads from S an entire line of text as a list of
    tokens (token = atomic lexical element). If the
    line is empty then the empty list is returned. At
    end-of-file, the atom 'end_of_file' is returned.

get0(-N)
    Gets the Unicode code of the next char from the current
    input stream. At end-of-file, the code specified by the
    eof_code flag is returned.

get0(+S,-N)
    Gets the Unicode code of the next char from
    stream S. At end-of-file, the code specified by the
    eof_code flag is returned.

get(-N)
    Gets the Unicode code of the next printing char from
    the current input stream. End-of-file is denoted
    by the value associated with the eof_code flag.

get(+S,-N)
    Gets the Unicode code of the next printing char from S.
    End-of-file is denoted by the value associated with the
    eof_code flag.

get_line(-A)
    Reads an entire line of text as an atom. At end of
    file returns the code specified by the eof_code flag.

get_line(+S,-A)
    Reads an entire line as an atom. At end-of-file returns
    the code specified by the eof_code flag.


peek0(-N)
    Similar to get0(-N), but it does not consume the
    returned char.

peek0(+S,-N)
    Similar to get0(+S,-N), but it does not consume the
    returned char.

peek(-N)
    Similar to get(-N),  but it does not consume the
    returned char.

peek(+S,-N)
    Similar to get(+S,-N),  but it does not consume the
    returned char.

skip(+N)
    Skips over chars in the current input stream until
    the first occurrence of the char with Unicode code N.

skip(+S,+N)
    Skips over chars in the current input stream until
    the first occurrence of the char with Unicode code N.


set_output(+S)
    Makes stream S the current output stream.

current_output(-S)
    Gets the current output stream.

write(+T)
    Writes the term T to the current output stream.

write(+S,+T)
    Writes the term T to the output stream S.

writeln(+T)
    Variant of write(+T) which outputs an extra
    newline char.

writeln(+S,+T)
    Variant of write(+S,+T) which outputs an extra
    newline char.

writeq(+T)
    Variant of write(+T) which quotes atoms where
    necessary so that read/1 could read the term back.

writeq(+S,+T)
    Variant of write(+S,+T) which quotes atoms where
    necessary) so that read/2 could read the term back.

writeqln(+T)
    Variant of writeq(+T) which outputs an extra
    newline char.

writeqln(+S,+T)
    Variant of writeq(+S,+T) which outputs an extra
    newline char.

print(+T)
    By default, print/1 is equivalent to write/1, but this
    can be changed by providing clauses for the user
    predicate portray/1: print/1 calls portray/1 before
    deciding what to do. If portray/1 succeeds, then it
    assumes the argument term has been printed. If portray/1
    fails and the term is atomic, then it writes the term
    using write/1. If portray/1 fails and the term is
    compound, then it writes the principal functor of the
    term using write/1 and them calls itself recursively on
    the arguments of the term. These rules do not apply
    to variables: print/1 uses write/1 to print them
    immediatly.

print(+S,+T)
    By default, print/2 is equivalent to write/2, but this can
    be changed by providing clauses for the user predicate
    portray/1. portray/1 can assume that during the
    execution of print/2, the current output stream is
    temporarily set to stream S. More details about print/2
    in the entry for print/1.

display(+T)
    Writes term to stream user_output, ignoring operators.

displayln(+T)
    Variant of display(+T) which outputs an extra
    newline char.

write_depth(+N1,+N2)
    Sets the maximum term depth and the maximum list
    length used by predicates write/1, write/2, etc.
    0 (zero) means no limit. The initial values are
    respectively 30 and 999.

put(+N)
    Writes the char with Unicode code N to the current output
    stream.

put(+S,+N)
    Writes the char with Unicode code N to the output stream S.

nl
    Writes a newline to the current output stream.

nl(+S)
    Writes a newline to the output stream S.

tab(+N)
    Writes N spaces to the current output stream.

tab(+S,+N)
    Writes N spaces to the output stream S.

flush
    Flushes the low-level buffer of the current output stream.

flush(+S)
    Flushes the low-level buffer of the stream S.


get_block(+S,+B,+N)
    Reads N bytes from the stream S into the buffer B.
    The previous contents of the buffer is destroyed.
    If the end-of-file is encountered, the actual number
    of transfered bytes can be lower than N. To find out
    the exact number of transfered bytes use the
    goal buffer_size(B,X,X).

get_block(+S,+B)
    Reads the entire stream S into the buffer B.
    To find out the exact number of transfered bytes
    use the goal buffer_size(B,X,X) (or use
    fs_property(FName,size,X) before reading, if the stream
    is a file stream).

put_block(+S,+B)
    Writes the entire contents of the buffer B to the stream S.


current_stream(-Name,-Mode,?Stream)
   Provides read-only access to the internal
   stream table. Can also be used to generate, through
   backtracking, all the existing streams.

current_stream(-Name,-Mode,-Path,?Stream)
   Similar to current_stream/3, but also provides the value of Path.
   If you do not need the value of Path, use the first version
   because it is much more efficient.

streams
    Shows details about all the currently opened streams.

'$set_user_streams'(+S1,+S2,+S3)
    This is a low-level hack that you rarely will need to use,
    if at all. It replaces the three standard user streams -
    'user_input', 'user_output' and 'user_error' - even if
    they are supposedly constant. This comes in handy for redirecting
    input and output already committed to the standard user streams: for
    example, to provide the normal top-level interaction through
    an Internet connection (see file pl/net.pl); another example,
    to redirect to a log file the error messages issued through
    'user_error' (use '$set_user_streams'(user,user,YourLogFile)
    to achieve this).

'$restore_user_streams'
    Restores the original user streams, canceling the effects
    of '$set_user_streams'/3.

Input/Output - Dec-10 Prolog Compatibility Text Streams
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The six predicates in this section are provided only for backward
compatibility.

These predicates are prone to problems concerning ambiguities in filenames
and changing of the working directory. For example, the call see(myfile)
is unable to open the file 'myfile' if another file with the same name,
but located in a different directory is still open. On the other hand,
see('./myfile') may open a second stream over the local file 'myfile'
because, technically, 'myfile' and './myfile' are different names.

ISO Prolog introduced the following six safe replacement predicates,
all described in the previous section: open/3, current_input/1,
set_input/1, current_output/1, set_output/1, close/1.

see(+S)
    If S is an atom, the file named S is opened (if not
    already open) and is made the current input stream. If S
    is a stream term then is made the current input stream.

seeing(-S)
    Gets the current input stream except that if the current input
    stream is 'user_input' the atom 'user' is returned.

seen
    Closes the current input stream.

tell(+S)
    If S is an atom, the file named S is opened (if not
    already open) and is made the current output stream. If S
    is a stream term then is made the current output stream.

telling(-S)
    Gets the current output stream except that if the current input
    stream is 'user_output' the atom 'user' is returned.

told
    Closes the current output stream.

Input/Output - Binary File Streams
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Besides text file streams, CxProlog also supports binary file streams.
Some of the predicated described in the two previous sections are
compatible with binary file streams.

Binary file streams are created using open/4, closed using
close/1 and processed using get0/1, get0/2, peek0/1, peek0/2,
put/1 and put/2. These last four predicated behave differently with
binary streams in that they only allow codes in the range 0..255
(not the Unicode range).

Te three block oriented predicates - get_block/2, get_block/3 and
put_block/2 - also work with binary streams.

To open a stream in binary mode you specify 'binary' as
the encoding in open/4.

**Important note:**
The end-of-file code for binary file streams is -1, and this
cannot be changed, unlike the end-of-file code for text file streams.


Input/Output - Buffer Streams
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The predicates open_buffer_stream/3 and open_buffer_stream/4 open
a stream over a buffer. All the existing input/output operations are
compatible with buffer streams.

Any Linux supported character encoding, e.g 'en_US.iso885915' or
'sr_YU.iso88595@cyrillic' can be associated to a buffer stream at
opening time, using open_buffer_stream/4. Note that a buffer
always contains uninterpreted binary data but a buffer stream
can interpret it as any kind of encoded text.

A buffer stream can also be opened in binary mode: specify 'binary'
as the encoding.

Opening two streams over the same buffer is not supported (the
behaviour in undefined).

**Important note:**
The end-of-file code for buffer streams is -1, and this cannot be changed.

open_buffer_stream(+B,+M,-S)
    Opens a stream S over buffer B. The mode M is one
    of the atoms: 'read', 'write', 'append'.
    The character encoding that becomes associated with
    the stream is the default encoding, as defined in the
    current locale Linux environment (no currently defined
    locale means locale "C").
    
open_buffer_stream(+B,+M,+E,-S)
    Similar to open_buffer_stream/3 except that an explicit
    character encoding can be specified using the atom E.
    Any Linux supported character encoding can be used,
    e.g. 'en_US.utf8' or 'pt_PT.iso885915@euro'. The atom
    'text' and 'binary' are recognized as special
    encodings: 'text' stands for the default encoding, as
    defined in the current locale Linux environment;
    'binary' opens the stream in binary mode.

Input/Output - Null Streams
~~~~~~~~~~~~~~~~~~~~~~~~~~~
A null stream is an output stream that throws away characters and terms written
to it. Null streams are created using open_null_stream/1, closed using close/1,
and any output operation can be applied to them.

open_null_stream(-S)
    Creates a new null stream which is returned in S.

OS Services
~~~~~~~~~~~
The following predicates provide direct access to some operating
systems services.

For the most part, the OS only understands text data in the
default char encoding. All the necessary conversions, to and
from the fixed internal UTF-8 encoding, are performed
automatically and transparently. This applies to filenames,
OS environment variable names, OS environment variable contents
and command line arguments.


**Note:**
Most of these predicates only work under Unix and Classic MacOS
(versions 7.x, 8.x, 9.x). Under other operating systems they fail.


os_name(-A)
    Gets the name of the underlying operating system.
    As yet, the possible results are:
    'unix', 'mac', 'unknown'

os_run(+A)
    Runs command A. Succeeds in case of successful
    command completion.

system(+A)
    Edinburgh Prolog/C-Prolog compatibly predicate.
    Identical to os_run/1.

sh
    Edinburgh Prolog/C-Prolog compatibly predicate.
    Identical to os_run('sh').

os_env(+A,-Ar)
    Accesses environment variables.
    Example: os_env('PATH',X)

os_arg(+A,-Ar)
    Gets individual command line arguments.
    Example: os_arg('-boot',X)

os_args(-L)
    Gets entire command line as a list of atoms.
    Example: os_args(X)

File System
~~~~~~~~~~~
The hierarchic file system can be examined and changed using the
predicates in this section.

*Filenames* are atoms.

The *current directory* (an absolute path) is represented as a reversed
list of filenames. This is an OS independent representation. Examples:

   - Unix: "/usr/bin/ls" ---> CxProlog: \[ls,bin,usr\]
   - Unix: "/"           ---> CxProlog: \[\]
   - MacOS: "HD20:Appl"  ---> CxProlog: \['Appl','HD20'\]
   - MacOS: "HD20"       ---> CxProlog: \['HD20'\]

**MACOS SPECIFIC NOTE:**
Under MacOS, CxProlog introduces a "virtual root",
denoted by the empty list \[\], where all the currently mounted volumes
are logically placed. Therefore, when the current directory is the
"virtual root", the predicate fs_files/1 returns the names of all the
currently mounted volumes (which are, therefore, treated as ordinary
directories).

The following predicates work under every operating system:


fs_exists(+F)
    Checks if there is a file/dir named F.

fs_rename(+Fo,+Fn)
    Renames existing file/dir Fo as Fn. If Fn is the
    empty list \[] then Fo is deleted.

fs_delete(+F)
    Deletes existing file/dir F. Only empty directories
    can be deleted.


file_exists(+F)
    Quintus-Prolog compatibility predicate.
    Identical to fs_exists/1.

rename_file(+Fo,+Fn)
    Quintus-Prolog compatible predicate.
    Identical to fs_rename/2.

delete_file(+F)
    Quintus-Prolog compatibly predicate.
    Identical to fs_delete/2.


exists(+F)
    Edinburgh Prolog/C-Prolog compatibly predicate.
    Identical to fs_exists/1.

rename(+Fo,+Fn)
    Edinburgh Prolog/C-Prolog compatibly predicate.
    Identical to fs_rename/2.

The following predicates work only under Unix and Classic MacOS
(versions 7.x, 8.x, 9.x). Under other operating systems
they return dummy results, such as the empty list [], or fail.

fs_property(+F,+A,-R)
    R is the value of the property A of existing
    file/dir F. As yet, the supported properties are:

    ========      =============================
    Property      Possible results
    ========      =============================
    type          'file', 'dir', 'other'
    size          the size of the file in bytes
    readable      'false', 'true'
    time          [access_time, modification_time]
    ========      =============================

fs_cd(-L)
    Obtains the current directory.

fs_cd(-Lo,+Ln)
    Changes the current directory from Lo to Ln.

fs_home
    Resets the current directory.

fs_files(-L)
    Gets all files/dirs inside the current directory.

Flags
~~~~~
"The flags" are some internal system flags which allows certain aspects of
the behaviour of CxProlog to be modified.


flag(+A,-T)
    Queries the value of flag A. Possible values are
    'on', 'off' or an integer in a range that
    depends on each particular flag.

flag(+A,-To,+Tn)
    Gets or changes the value of flag A. The old value of A is
    To and the new value is Tn. Possible values are
    'on', 'off' or an integer in a range that
    depends on each particular flag.

flags
    Shows the current status of all CxProlog flags.

Description of the flags:

debug
    Controls the current debugger working mode.
    Allowed range is 0-2:

        - 0 - debugger is off;
        - 1 - debugger is in 'debug' mode;
        - 2 - debugger is in 'trace' mode.
        - DEFAULT=0.

interrupt
    Controls the effects of a CTRL-C interrupt.
    Allowed range is 0-4.

        - 0 - interrupt is ignored;
        - 1 - interrupt activates 'debug' mode;
        - 2 - interrupt activates 'trace' mode;
        - 3 - interrupt aborts the current execution;
        - 4 - interrupt presents a menu of possible actions.
        - DEFAULT=4.

fail_on_error
    Allows runtime errors to produce "failure" instead of
    "restart". Allowed range is 0-2:

        - 0 - errors generate restart;
        - 1 - errors generate failure, but the error messages
          are displayed anyway;
        - 2 - errors generate failure and the error messages
          are suppressed.
        - DEFAULT=0.

compatible_if_then
    If 'on', *(G1->G2)* is equivalent to *(G1->G2;false)*
    as in most Prologs. If 'off', *(G1->G2)* is
    equivalent to *(G1->G2;true)*, which is more
    sound logically. DEFAULT=on.

extra_spaces_in_terms
    If 'on', the terms are written with one extra space inserted after
    each comma separator and one extra space inserted after the bar
    separator inside a list. Examples of output: a(1, 2, rt), [1, 2| rt].
    If 'off' no extra spaces are added as in a(1,2,rt), [1,2|rt]. DEFAULT=off.

compatible_strings
    If 'on', any double-quoted literal, like "hello", is
    interpreted as a list of Unicode char codes (which,
    sometimes, is also a valid evaluable expression
    -- see is/2). If 'off', any double-quoted literal
    is interpreted as an application of functor '""'/1
    to some Prolog term. Example: "1.3" --> '""'(1.3).
    DEFAULT=on.

bar_is_semicolon
    If 'on', the atom '|' is automatically translated
    to the atom ';' (except in contexts where '|'
    is denoting "the reminder of a list"). This is the behaviour compatible
    with more prologs. If 'off' no translation is performed. DEFAULT=on.

restricted_args
    Controls whether it is active the usual restriction that the arguments
    of a compound term or list must be expressions with precedence below
    1000 (the precedence of the comma operator). If 'off', terms as such are
    allowed::

                    a(b,c;d)          a(b-->c)       [a,b;c,d]

    If 'on' these terms must be rewritten with added parenthesis, like this::

                    a(b,(c;d))        a((b-->c))     [a,(b;c),d]

    DEFAULT=on (for compatibility with most prologs).

eof_code
    Specifies the end-of-file code for text files. -1 achieves
    compatibility with Quintus Prolog. 26 achieves
    compatibility with C-Prolog. DEFAULT=-1

keep_source
    If 'on', the clauses are internally stored in
    double format: "compiled format" and "source
    format". This is a bit redundant but predicates
    clause/2, retract/1 and listing/1 will only work
    with predicates asserted at a time this flag is
    'on'. Setting this flag to 'off' saves around 40%
    of database space (in subsequent asserts or
    consults). DEFAULT=on.

force_quoted
   If 'on', forces write/1, write/2, writeln/1, writeln/2
   and atom_term/2 to behave in 'quoted' mode. Useful
   for debugging, sometimes. DEFAULT=off.

undef_warnings
    If 'on', a warning is issued whenever an undefined
    predicate is invoked. Useful for debugging.
    DEFAULT=on.

memory_warnings
    If 'on', a warning message is issued whenever an
    internal "elastic memory area" automatically grows.
    Useful to be aware of the rate of memory
    consumption. DEFAULT=on.

garbage_collection
    Controls whether the garbage collector of atoms
    is active or not. DEFAULT=on.

index_params
    States how many parameters should be used in
    building predicate indexes. Allowed range is
    0..3, 0 meaning no predicate indexing
    is required. DEFAULT=1.

float_display_precision
    Controls how floats are displayed.
    If > 0, they are displayed with at least the
    indicated number of significant digits and
    using either decimal notation or scientific
    notation, whichever is shorter.
    If <= 0, they are displayed with exactly the
    indicated number of decimal places in decimal
    notation. DEFAULT=10.

sys_trace
    Sets the desired level of detail of the info produced by
    the low-level runtime tracer. Allowed range is 0-3:

        - 0 - disabled;
        - 1 - show all builtin predicate calls;
        - 2 - show all predicate calls;
        - 3 - show the complete trace of the execution of the
          prolog machine.

    The debugging output is placed in the file 'sys_trace.log'.
    Beware, this file can grow very large. DEFAULT=0.

test_rellocation
    If 'on', activates a self-testing mode that makes
    the rellocation algorithms of the self-expanding
    control stacks (global, local, trail e finalizers)
    run continuously.
    DEFAULT=off.

test_garbage_collection
    If 'on', activates a self-testing mode that makes
    the garbage collector of atoms run continuously.
    DEFAULT=off.


Imperative Variables (ivars)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
An "ivar" is a special name that can be freely bound/rebound to different
Prolog terms using the "assignment operator" :=/2. The effects of the
assignment operator are not automatically reversed on backtracking.

The effects of the "backtrackable assignment operator" - &:=/2 - are
automatically reversed on backtracking. There is also a meta predicate -
with_ivar/3 - which proves a goal with some ivar temporarily set to some value.

The following constant ivars are predefined in CxProlog:
'user_input', 'user_output', 'user_error', 'user'.


ivar(+A)
    A is a currently defined ivar.

+A := +T
    Normal assignment. Sets ivar A to term T. Always succeeds.

+A &:= +T
    Backtrackable assignment. Sets ivar A to T, but
    automatically restores the previous state and value
    of A on backtracking. Always succeeds.

+A ?:= +T
    Creation assignment. Initializes ivar A with T
    only if A does not exist already. Nothing is done if A
    already exists. Always succeeds.

+A #:= +T
    Constant assignment. Sets the ivar A to T and makes it a
    CONSTANT. The ivar A is automatically created if
    necessary. Always succeeds.

+A =: -T
    Gets the current value of ivar A. Fails if A is undefined.

with_ivar(+A,+T,+G)
    Proves goal G with the ivar A temporarily set to term T.
    Here is an approximate definition:
    *with_ivar(A,T,G) :- A =: X, A &:= T, G, A &:= X.*
    The real version also deals with cuts and with the
    case A is undefined.

ivar_delete(+A)
    Deletes the ivar A. Always succeeds.

current_ivar(-A,-T)
    Generates, through backtracking, all the existing
    ivars and the corresponding values.

ivars
    Shows all the existing ivars and corresponding values.

Imperative Queues
~~~~~~~~~~~~~~~~~
On the following predicates, Q stands for a queue (a new primitive
type) or for an ivar bound to a queue.

A queue can store terms of any kind: for example it can mix integers,
queues and dictionaries. The queues are "imperative" in the sense that
the effects of the queue operations are not automatically undone
on backtracking.


queue(+Q)
    Q is a queue.

queue_new(-Q)
    Creates a new queue Q.

queue_clear(+Q)
    Clears the queue Q.

queue_delete(+Q)
    Deletes the queue Q.

queue_put(+Q,+T)
    Puts the term T at the end of the queue Q.

queue_get(+Q,-T)
    Gets the term T from the front of the queue Q.

queue_peek(+Q,-T)
    Examines the front of the queue Q.

queue_write(+Q)
    Writes info about Q to the current output stream.

queue_write(+S,+Q)
    Writes info about Q to the stream S.

queue_as_list(+Q,-L)
    Converts the queue Q to a list L of terms.

current_queue(?Q)
    Generates, through backtracking, all the
    existing queues.

queues
    Shows all existing queues.

Imperative Stacks
~~~~~~~~~~~~~~~~~
On the following predicates, K stands for a stack (a new primitive
type) or for an ivar bound to a stack.

A stack can store terms of any kind: for example it can mix integers,
queues and dictionaries. The stacks are "imperative" in the sense that
the effects of the stack operations are not automatically undone on
backtracking.


stack(+K)
    K is a stack.

stack_new(-K)
    Creates a new stack K.

stack_clear(+K)
    Clears the stack K.

stack_delete(+K)
    Deletes the stack K.

stack_push(+K,+T)
    Pushes the term T on the stack K.

stack_pop(+K,-T)
    Pops term T from the stack K.

stack_top(+K,-T)
    Examines the top of the stack K.

stack_write(+K)
    Writes info about K to the current output stream.

stack_write(+S,+K)
    Writes info about K to the stream S.

stack_as_list(+K,-L)
    Converts the stack K to a list L of terms.

current_stack(?K)
    Generates, through backtracking, all the
    existing stacks.

stacks
    Shows all existing stacks.

Imperative Dictionaries
~~~~~~~~~~~~~~~~~~~~~~~
On the following predicates, D stands for a dict (a new primitive
type) or for an ivar bound to a dict.

A dict is a heterogeneous container that can store terms of any kind,
indexed by terms of any kind. A dict is "imperative" in the sense that the
effects of the dict operations are not automatically undone on backtracking.

Each key has a single value associated. So the retrieve predicate,
dict_get/3, is deterministic.

The dicts are kept automatically sorted so that the items could be
retrieved through binary search.


dict(+D)
    D is a dictionary.

dict_new(-D)
    Creates a new dictionary D.

dict_clear(+D)
    Clears the dict D.

dict_delete(+D)
    Deletes the dict D.

dict_set(+D,+Key,+T)
    Associates the term T with the key Key in the
    dictionary D.

dict_get(+D,+Key,-T)
    Gets T associated with Key in dictionary D.

dict_delete_item(+D,+Key)
    Deletes the key Key from the dictionary D.

dict_write(+D)
    Writes info about D to the current output stream.

dict_write(+S,+D)
    Writes info about D to the stream S.

dict_as_list(+D,-L)
    Converts the dictionary D to a list L of K-T pairs.

current_dict(?D)
    Generates, through backtracking, all the existing
    dicts.

dicts
    Shows all existing dictionaries.

Imperative Arrays
~~~~~~~~~~~~~~~~~
On the following predicates, D stands for an array (a new primitive
type) or for an ivar bound to an array.

An array is a specialized dictionary which is indexed by (small) positive
integers, starting at 1. An array grows automatically, as needed.
The store and retrieve operations are very fast and performed in
constant time.


array(+D)
    D is a array.

array_new(-D)
    Creates a new array D.

array_clear(+D)
    Clears the array D.

array_delete(+D)
    Deletes the array D.

array_set(+D,+Idx,+T)
    Associates the term T with the index Idx in the
    array D.

array_get(+D,+Idx,-T)
    Gets T associated with Idx in array D. Fails if there
    is no term associated with index Idx in D.

array_delete_item(+D,+Idx)
    Deletes the term at Idx from the array D.

array_write(+D)
    Writes info about D to the current output stream.

array_write(+S,+D)
    Writes info about D to the stream S.

array_as_list(+D,-L)
    Converts the array D to a list L of Idx-T pairs.

current_array(?D)
    Generates, through backtracking, all the existing
    arrays.

arrays
    Shows all existing arrays.

Imperative Buffers
~~~~~~~~~~~~~~~~~~
On the following predicates, B stands for a buffer (a new primitive
type) or for an ivar bound to a buffer.

A buffer is a specialized array which stores small integers in the range
0..255 (bytes). A buffer grows automatically, as needed. The store and retrieve
operations are very fast and performed in constant time.

Unlike the imperative arrays, all positions of a buffer are automatically
initialized with zero. Therefore there are never undefined positions and the
retrieve operation - buffer_get/1 - never fails.

CxProlog supports opening a stream over a buffer in order to perform
sequential reads and writes via the normal input/output operations (cf. section
_`Buffer Streams`).

CxProlog also supports reading large chunks of information from a file to
a buffer, and writing large chunks of information from a buffer to a file (cf.
section _`Binary File Streams`).


buffer(+B)
    B is a buffer.

buffer_new(-B)
    Creates a new buffer B.

buffer_clear(+B)
    Clears the buffer B.

buffer_delete(+B)
    Deletes the buffer B.

buffer_size(+B,-No,+Nn)
    Queries and changes the size of the buffer B. The old size
    is No and the new size is Nn. The size of the buffer is
    managed automatically, but you may need to truncate a
    portion at the end.

buffer_set(+B,+Idx,+N)
    Associates the value N with index Idx in buffer B.

buffer_get(+B,+Idx,-N)
    Gets N associated with Idx in buffer B. Never fails as
    all non assigned positions implicitly have the value zero.

buffer_write(+B)
    Writes info about B to the current output stream.

buffer_write(+S,+B)
    Writes info about B to the stream S.

current_buffer(?B)
    Generates, through backtracking, all the existing
    buffers.

buffers
    Shows all existing buffers.

Handling Transient Text
~~~~~~~~~~~~~~~~~~~~~~~
In CxProlog, the recommended way of dealing with transient text is
through atoms, with the help of predicates get_line/1, get_line/2,
concat/2 and slice/4. These predicates are very flexible and CxProlog
includes a garbage collector of atoms that safely recycles again
and again the space taken by transient text.


slice(+A,+Na,+Nb,-Asub)
    Asub is the subatom of atom A that includes the characters of A in
    the closed interval defined by offsets Na and Nb. Two different
    coordinate systems are supported: (1) positive offsets are relative
    to the beginning of A; (2) negative offsets are relative to the
    ending of A. Examples::

        slice('ABC',1,2,Asub)        -->  Asub = 'A'
        slice('ABC',-2,-1,Asub)      -->  Asub = 'BC'.
        slice('ABC',2,-1,Asub)       -->  Asub = 'BC'.
        slice('ola.pl',-3,-1,'.pl')  -->  true.
        slice('ABC',1,-1,Asub)       -->  Asub = 'ABC'
        slice('ABC',2,1,Asub)        -->  Asub = ''
        slice('ABC',10,100,Asub)     -->  Asub = ''
        slice('ABC',-20,-10,Asub)    -->  Asub = ''
 
concat(+L,-A)
    Takes the textual representations of all the terms
    in L and concatenates everything into the returned
    atom A. Sublists in L are subjected to the
    recursive application of concat/2. Example::

        ?- concat(['ole ',f(a),'Az',[[a]]],X), writeln(X).
        ole f(a)Aza
        X='ole f(a)Aza'

-A === +L
    Same as concat(+L,-A). Note the reversed order of the
    parameters, comparing with concat/2. This is because we
    want ===/2 to be used as a kind of assignment operator.


Threads (coroutines)
~~~~~~~~~~~~~~~~~~~~
On the following predicates, Z stands for a thread (a new kind of
primitive type) or for an ivar bound to a thread.

The threads are organised in TREE. Killing a thread also kills all
its descendants


thread(+Z)
    Z is a thread.

thread_new(-Z, +Goal, +RestartGoal)
    Creates a new thread Z. Goal is the startup goal.
    RestartGoal is the goal that is activated
    in case of error or explicit restart/0 call.

thread_transfer(+Z,-A)
    Transfers control to the thread Z. Possible results
    are: 'going', 'completed', 'failed', 'killed', 'error'.

thread_kill(+Z)
    Kills the thread Z.

active_thread(-Z)
    Z is the active thread.

active_thread_completed
    Finishes the active thread making it return
    'completed'.

active_thread_failed
    Finishes the active thread making it return 'failed'.

current_thread(?Z)
    Generates, through backtracking, all the existing
    threads.

threads
    Shows all existing threads.

Sockets
~~~~~~~
These four predicates enable CxProlog to act either as a server or as a
client over an Internet link.

The first three are "server predicates". As a piece of advice, it is a good
idea to span a new process with the purpose of handling each incoming
connection. This way the client does not have to wait for too long.

The last predicate is the sole "client predicate".


net_install(+N)
    Activates a local server socket listening to port N.
    Only one server per process is supported.

net_uninstall
    Closes the local server socket.

net_accept(-S1,-S2)
    On the server side, waits for the next incoming connection
    and then opens 2 streams for handling the communication.
    S1 is the input stream where the requests arrive.
    S2 is the output stream to where the replies are sent.

net_connect(+A,+N,-S1,-S2)
    Connects, as a client, to the server A, port N, and
    open two streams to handle the communication.
    S1 is the input stream where the replies arrive.
    S2 is the output stream to where the requests are sent.

Processes (experimental)
~~~~~~~~~~~~~~~~~~~~~~~~
On the following predicates, P stands for a process (a new kind of
primitive type) or for an ivar bound to a thread.

**Note:** These predicates only work under Unix. They are implemented using the
Unix primitives 'fork', 'pipe', 'write' and 'read'.

The father process may create as many child processes as it wishes.
The father process cannot kill any of its child processes.
But a child process can kill itself using halt/0 or exit/0.

There is a private unidirectional channel of communications between each
child and father. Messages are nonnegative integer number.

Internally, some negative numbers may also be send through the channel, for
bookkeeping purposes. For example, when a child dies, the message -1 is
passed to the father, instructing it to set the child descriptor
to "not-alive" state. This update is automatic.


process(+P)
    P is a process.

process_new(-P, +Goal, +RestartGoal)
    Creates a new child process P. Goal is the startup goal.
    RestartGoal is the goal that is activated
    in case of error or explicit restart/0 call.

process_send_father(+N)
    Child sends message N to its father.
    N is a nonnegative integer.

process_send_father_max(-N)
    N is the number of consecutive sends that puts
    the system in a dead-lock state, if the father
    never reads the messages.

process_receive_from_child(-P,-N)
    Father receives message N from its child process P.
    This is a blocking primitive: if there is no message
    available, the father waits. N is a nonnegative integer.

process_receive_from_child_ready
    Non-blocking primitive that checks whether or not
    there is a message available.

current_process(?P)
    Generates, through backtracking, all the existing
    child processes.

processes_clean_dead
    Discard the dead.

processes
    Shows all the child processes.

Debugger
~~~~~~~~
There is a overview of the debugger in a separated section, further below
in this document.

Is this section we restrict ourselves to describing the builtin predicates
related to the debugger.


debug
    Switches "debug mode" on. The debugger will
    trace the execution of the first encountered
    predicate with a spy point set. Equivalent to
    *flag(debug,_,1).*

trace
    Switches "trace mode" on. The debugger will
    trace the execution of the first encountered
    non-builtin predicate (even if it has not a
    spy point set. This allows exhaustive
    tracing of a program. Equivalent to
    *flag(debug,_,2).*

nodebug
    Switches debug mode off and removes all spy points.
    Equivalent to *flag(debug,_,0).*

notrace
    Same as nodebug/0.

debugging
    Displays information concerning the current state of
    debugger, including the list of active spy points
    and the current leashing mode.

leash(Mode)
    Sets "leashing mode" to Mode, where Mode is one of
    the following atoms:

    - 'full'  - prompt on call, exit, next, fail
    - 'tight' - prompt on call, next, fail
    - 'half'  - prompt on call, next
    - 'loose' - prompt on call
    - 'off'   - no prompt
    - DEFAULT = 'half'

    When an event causes the debugger to display
    information, if that event is "leashed"
    then the debugger stops there to allow user to
    interact.
    The events 'redo' and 'cut' cannot be leashed.

spy Spec
    Sets spy points on all predicates described by Spec.
    Spec can be an atom, a functor or a list of atoms
    and functors. All events associated with a
    predicate with a spy point set, will force the
    debugger to prompt the user (even if leashing is
    off).

nospy Spec
    Removes the spy point for the predicates given by Spec.

nospyall
    Removes all spy points from all predicates.

External Interface with Java
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Java interface in an optional CxProlog component that is not
instaled by default. The install instructions are inside the file
src/Makefile.

The Java interface allows Prolog code to invoke Java code, making the
full funcionality of the Java plataform available inside CxProlog. This
implementation is based on the Java Native Interface (JNI), a standard
component of the Sun's Java distribuition.

The integration is fairly seamless. For example, the Java exceptions that may
be generated by the Java code are automatically converted to regular Prolog
exceptions which can be handled by Prolog code.

CxProlog introduces a specific new primitive type of "Java object terms"
to represent Java reference types, that is objects and arrays. Each such
Java object term simply memorises the external reference of an object or
array and is displayed like this: *1'JOBJ_404ad640*. The null object
is conventionally represented by the Prolog atom 'null'.

The eight Java primitive types are mapped to existing Prolog
types according to the following table:

   =======    ==================================================================
   JAVA       PROLOG
   =======    ==================================================================
   boolean    atoms 'false' and 'true'
   byte       integer in the range -128 .. 127
   char       char
   short      integer in the range -32768 .. 32767
   int        number (float is used if the number does not fit a Prolog integer)
   long       number (float is used if the number does not fit a Prolog integer)
   float      number
   double     number
   =======    ==================================================================

In CxProlog, most Java predicates require the explicit indication of a
Java type in their arguments. Those types must be written in the so
called JNI format. The syntax of the JNI types is defined by the following
grammar::

    <type> ::=
         Z                   // boolean
       | B                   // byte
       | C                   // char
       | S                   // short
       | I                   // int
       | J                   // long
       | F                   // float
       | D                   // double
       | L<classname>;       // object of class "classname"
       | [<type>             // array of type "type"
       | (<typeseq>)<type>   // method returning "type"
       | (<typeseq>)V        // void method
    <classname> ::=
         <name>
       | <name>/<classname>
    <typeseq> ::=
         // can be empty
       | <typeseq><type>

For example, a simple integer has JNI type 'I', a simple array of
integers has type *'[I'*, and a two dimensional arrays of strings has
JNI type *'[[Ljava/lang/String;'*.

The Java predicates of CxProlog that deal with methods and fields require the
explicit indication of a Java signature written also in the JNI format. A JNI
signature is an atom consisting of a name, followed by one ':',
followed by one JNI type. For example, the signature of the Java method
'newInstance' from the class 'java.lang.reflect.Array' is written:
*'newInstance:(Ljava/lang/Class;I)Ljava/lang/Object;'*.

There are some examples you can study available in the examples directory.


java_call(+ClassOrInstance, +MethodSignature, +ArgList, -Result)
    Invoke a Java method or constructor. All methods and constructors are
    acessible, even the private ones.

    ClassOrInstance is either an atom, representing the name of a class
    e.g. 'java/lang/System', or a Java object term previously returned by
    other Java predicat invocation.

    MethodSignature is the signature of the method, e.g.
    'getName:()Ljava/lang/String;'. If the first argument represents a class,
    the method is assumed to be either a constructor, a static method
    or a method of the metaclass java.lang.Class; otherwise the first argument
    represents a regular object and the method is is assumed to be an instance
    method. Every constructor has the conventional name '<init>' and must
    return void, as in the constructor signature
    '<init>:(Ljava/lang/String;)V'. In the case of the creation of arrays,
    the only constructor signature allowed is '<init>:(I)V', as in
    java_call('[I', '<init>:(I)V', [100], R). Note that in this example '[I'
    is used as a class name.

    ArgList is the list of arguments (can be the empty list) and Result is the
    object returned by the method (if the return type is void,
    then the value returned is always the atom 'void').

java_field(+ClassOrInstance, +FieldSignature, -To, +Tn)
    Get or change the value of a class variable or an instance variable. All
    variables are acessible, even the private ones.
    ClassOrInstance is either an atom, representing the name of a class, or
    a Java object term previously returned by other Java predicat invocation.
    FieldSignature is the signature of the variable, e.g. 'intArr:[I'.
    The old value of the variable is To and the new value is Tn.

java_array(+ArrayType, +Array, +Index, -To, +Tn)
    Get or change the value of an array element. ArrayType is an atom
    representing the type of the array e.g. '[[[I', Array is the array object
    itself; Index is the position to access (starting at 0);
    To is the old value; Tn is the new value.
    Example:  java_array('[I',Obj,3,_,99999).

java_convert(+Type, ?JavaTerm, ?PrologTerm)
    Converts terms between a Java representation and a Prolog representation.
    The supported convertions are: string <-> atom; class <-> atom;
    array <-> list. Example: java_convert('[I', JavaArray, [1,2,3,4,5]).

java_same(+Obj1, +Obj2)
    Checks whether the Java object terms Obj1 and Obj2 are the same. It is
    important never to use =/2 to check identity between two Java object terms
    because two distinct reference may represent the same object (this is
    due to the way the objects are internally managed in Java).


Customising CxProlog
====================

Alternative Boot Files
~~~~~~~~~~~~~~~~~~~~~~
It is possible to specify an alternative boot file, using the command
line argument '-boot'. Another method is to invoke the C-function
'SpecifyBootFile(.)' from inside C-function 'YourPrologue()' - as in
SpecifyBootFile("MyBootFile.pl").

Through the definition of a boot file, the user is able to customise the
following aspects of the CxProlog system:

   - Replace the default top-level user-iteration;
   - Add extra builtin predicates written in Prolog: all predicates
     defined inside the boot file, or loaded from commands inside
     the boot file, are taken as builtin;
   - REDEFINE predefined builtin predicates: it is necessary to issue
     an abolish_builtin/2 command, prior to each such redefinition;
   - RENAME predefined builtin predicates: this is done by issuing
     a rename_builtin/3 command;
   - Define MUTABLE builtin predicates: it is necessary to issue
     an mutable_builtin/2 command, prior to each such definition.

Every alternative boot file MUST provide a definition for the following
two predicates:

'$cxprolog_initialise'
    Perform any initialisation that might be required.
    It is activated on startup.

'$cxprolog_top_level_goal'
    Perform the top-level user-iteration concerning a
    SINGLE goal. It is reactivated again and again
    after every:

    - top-goal completion;
    - explicit 'restart/0' or 'abort/0' call;
    - error message
    - CNTL-C interrupt (depending on the status of
      the 'interrupt' flag).

These predicates may fail or succeed after doing their job. It doesn't
matter.

Nothing else is required or assumed by CxProlog, concerning alternative
boot files.

The accompanying file "CxBoot.pl" serves as an example of a simple boot
file. Actually, the contents of this file match the default used by
CxProlog when no boot file is provided (see `Default Boot`_).

Default Boot
~~~~~~~~~~~~
Missing the conventional command line argument '-boot' (or a
'SpecifyBootFile' C-function invocation) CxProlog does not load any
boot file whatsoever. Instead, it installs a default top-level
interaction oriented toward program development.

There are some minor builtin predicates introduced in the default boot:


push +U
    Pushes the unit designator U on top of current
    context. Therefore changes the current unit
    to be used in the top-level iteration.

pop
    Pops the current context. Therefore restores the
    previous current unit, which will be used in
    the top-level iteration

Adding Builtin Predicates Written In C
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is done inside the function YourExtensions(), in file "YourExtensions.c".
Please read the cautionary notes and guidelines included in the file.


Overview of the Debugger
========================

The builtin predicates related to the debugger are presented above, in the
subsection _`Debugger` of the the section _`CxProlog Builtin Predicates`.

Here we present an overview of the debugger and describe the user interaction.

Introduction
~~~~~~~~~~~~
The CxProlog debugger is based on the classical "procedure box" control
flow model: during execution, at each procedure call, the debugger builds
a "procedure box" containing a copy of the invoked predicate. Each procedure box
includes four ports named 'call', 'exit', 'redo' and 'fail'.

During execution the debugger keeps building procedure boxes so that the flow
of control would proceed through those ports. Each kind of port
is transversed (entered or exited) in diferent circumstances:

- call - entered on predicate activation;
- exit - exited on success;
- redo - entered on backtracking (so to consider the next alternative);
- fail - exited on failure (when there are no alternatives left).

Transversing a port generates a "port event" that makes the debugger display
a line of debugging information.

CxProlog considers two further kinds of events - "cut events"
and "next events" - that occur inside the procedure boxes and are activated
in the following circumstances:

- cut  - activated when the control directive !/0 is executed, in a clause;
- next - activated when, after "deep backtracking" (via a 'redo' port) the next
  clause is tried; "shallow backtracking" (inside the box) does not generate
  'next' events.

The debugger allows the user to creep, that is single-step, through the
debugging events while they are generated. This is bound to produce
too much information but the commands 'skip' and 'leap' allow the
user to trim unwanted information:

- skip  - focus on information concerning a specific procedure box (usually
 the current one; each box is identified by a unique sequential number);
- leap - focus on information concerning some predicates of interest
 previously marked with a "spy points".

Important rules concerning builtin predicates:

- The internal execution of a builtin predicate is untraceable.
  In other words, the box of a builtin predicate is a "black box"
  for debugging purposes: what's happening inside cannot be seen.
- The internal execution of an user predicate is always traceable,
  even if the user predicate is activated from a builtin predicate.
- spy points can be placed on user predicates, but not on builtin
  predicates.

Debugging Line
~~~~~~~~~~~~~~
Consider this small program::

   z:-a,!,b,fail.
   z.
   a.
   b.
   b.

Here is the result of single-stepping through this program, in trace
mode, with a spy point placed on a/0 and with leashing set to 'half'::

 (trace) [main] ?- z.
      2 (  1) call: [main]: z ?
     * 1 (  2) call: [main]: a ?
     * 1 (  2) exit: [main]: a ?
      0 (  1)  cut: [main]: z
       2 (  3) call: [main]: b ?
       2 (  3) exit: [main]: b
       b (  4) call: [main]: fail ?
       b (  4) fail: [main]: fail
       2 (  3) redo: [main]: b
       1 (  3) next: [main]: b ?
       1 (  3) exit: [main]: b
       b (  5) call: [main]: fail ?
       b (  5) fail: [main]: fail
       1 (  3) redo: [main]: b
       0 (  3) fail: [main]: b
     * 1 (  2) redo: [main]: a ?
     * 0 (  2) fail: [main]: a ?
      0 (  1) fail: [main]: z
 no

About the meaning of "leashing", please consult the information about the
predicate 'leash/1'.

Each component of the debugging line has a meaning:

Component 1 (1 char)
    "\*" - if present, indicates a spy point;

Component 2 (1 char)
    ">" - if present marks an event that has been reached in a special way,
          that is not by single-stepping. The alternatives are:

        - point of return from a 'skip' command;
        - point of return from a leap command;
        - point where a CNTR-C interrupted activated the debugger,
        - point where a CNTR-C forced the debugger to stop skipping or leaping.

Component 3 (1 char)
    The possibilities are:

      - b - builtin predicate;
      - i - imported predicate;
      - u - predicate undefined in the current unit;
      - 0..9# - number of remaining clauses, not yet considered in the
        execution of an user-defined predicate, plus the current clause
        (# represents any number >= 10);

Component 4 (a number in parenthesis)
    Unique invocation number associated with each procedure box.
    The invocation number is incremented for every fresh invocation
    that is displayed by the debugger. In other words, it is
    incremented whenever a call event shows up on the console.
    Some commands accept an invocation number as argument (see below).

Component 5 (event type)
    Type of the event that caused the line to be displayed.

Component 6 (context)
    The current context

Component 7 (goal)
    The current goal, printed using the current instantiation state.

Component 8 (char)
    "?" - if presents, prompts the user. Only apear on leashed ports.

Debugging Commands
~~~~~~~~~~~~~~~~~~
Each debugging command consists of one letter mnemonic, optionally followed
by a positive integer argument. Here we describe all the
available debugging commands:


Command h (help)
    Displays the following menu of available debugging commands.

	The CxProlog debug options are the following::

    CxProlog debug options:
          <ret> creep              + spy this             h help
           s<i> skip               - nospy this           d debug
           q<i> quasi-skip         i info                 t trace
           l leap                  g<n> ancestors         n nodebug
           r<i> retry              = debugging            a abort
           f<i> fail               : statistics           e exit
 
Command <ret> (creep)
    Continue execution, displaying debugging information for all the events,
    until a leashed event is reached. If leashing if off, a complete trace of
    the execution is given.

Command s<i> (skip)
    Continue execution, omitting all debugging information, until the next
    event concerned with the port <i> is reached. Argument <i> is optional:
    if not given, the number of the current box is used.

Command q<i> (quasi-skip)
    Combination of 'skip' and 'leap'. Continue execution, omitting all
    debugging information, until the next event concerned with the port <i>
    OR with a predicate with a spy point is reached. Argument <i> is optional:
    if not given, the number of the current box is used.

Command l (leap)
    Continue execution, omitting all debugging information, until the next
    event concerned with a predicate with a spy point is reached.
    By leaping throughout predicates with spy points, the user can follow
    the execution at a higher level than exhaustive tracing.

Command r<i> (retry)
    Execution is transferred back to the call port of box <i>, so an
    earlier state of computation is resumed. Argument <i> is optional:
    if not given, the number of the current box is used.

Command f<i> (fail)
    Execution is transferred to the fail port of box <i>. This amounts to
    manually fail the invocation associated with box <i>. Argument <i> is
    optional: the default is the number of the current box.

Command + (spy this)
    Place a spy point on the predicate in the current box.
    
Command - (nospy this)
    Remove any spy point from the predicate in the current box.

Command i (info)
    Shows information about the current goal and corresponding predicate,
    about the current context and about the current historic context.

Command g<n> (ancestors)
    Displays, in the current instantiation state, the goal that called the
    current one, then the one that called it, and so on. Some ancestors may
    be missing because only goals with associated procedure box are shown.
    Note that while skipping or leaping (see commands 'skip' and 'leap'), no
    procedure box is built.

Command = (debugging)
    Show the current debugging state. Equivalent to predicate debugging/0.

Command : (statistics)
    Show runtime information. Equivalent to predicate statistics/0.

Command n (nodebug)
    Turn off debugging. Equivalent to the predicate nodebug/0.

Command d (debug)
    Debugging proceeds in "debug mode". Equivalent to the predicate debug/0.

Command t (trace)
    Debugging proceeds in "trace mode". Equivalent to the predicate trace/0.

Command a (abort)
    Abort execution. Equivalent to the predicates restart/0 or abort/0.

Command e (exit)
    Exit CxProlog. Equivalent to predicate halt/0.



Writing CxProlog scripts for Unix
=================================

A CxProlog script is an executable text file starting with this line::

    #!/usr/local/bin/cxprolog -script

Use the command "chmod u+x myscript" to make a script file executable.

A script is run by simply writing its name in the Unix command line: CxProlog
is automatically activated, then it "consults" the script and finally exits
silently. Note that a script should contain at least one command: otherwise
no operation is performed when it runs.

Scripts are supposed to take advantage of the CxProlog builtin predicates that
provide interface to the operating system, including the very general predicate
system/2. Note that handling the output of Unix commands issued through system/2
can best be done using the tokenizer (accessible through read_tokens/1 and
read_tokens/2).

Sample Script
~~~~~~~~~~~~~

::

    #!/usr/local/bin/cxprolog -script

    % Displays the PID of all processes with "log" as part of their name.

    run_script :-
        system('ps -A | grep log > /tmp/aux'),
        open('/tmp/aux', read, S), read_pids(S, Ps), close(S),
        writeln(Ps).

    read_pids(S, Ps) :-
        read_tokens(S,T),
        (T == end_of_file
            -> Ps=[]
            ; T=[const_tk(P)|_], Ps=[P|Z], read_pids(S,Z)).

    :- run_script.


Testing CxProlog
================

In order to test CxProlog in your machine, consult the file 'pl/z.pl'.
Assuming you are using the default boot, the output should resemble
something like this::

    [main] ?- [z].
    File zbm.pl consulted 4748 bytes 0.00061035 sec.
    File zstr_io.pl consulted 27260 bytes 0.030366 sec.
    File ztokens.pl consulted 33336 bytes 0.041221 sec.
    File zutils.pl consulted 11564 bytes 0.01177 sec.
    6.2337e+05 lips for 50 iterations taking 0.039268 secs (0.039268-0)
    6.5643e+05 lips for 50 iterations taking 0.037314 secs (0.037314-0)
    a(_215,[we,45,_664])
    File zu.pl consulted 3596 bytes 0.0037994 sec.
    [c,b,a,main]
    [c,b,a,main]
    xxx: I am the c/0 version
    [c,b,a,main]
    [b,a,main]
    xxx: I am the b/0 version
    [c,b,a,main]
    [b,a,main]
    [b,a,main]
    xxx: I am the b/0 version
    [b,a,main]
    [a,main]
    [a,main]
    xxx: I am the a/0 version
    [c,b,a,main]
    [d(222),b,a,main]
    [yyy: I am the d/1 version,222]
    [[d(111),c,b,a,main],[c,b,a,main],[b,a,main],[a,main],[main]]
    [d(111),c,b,a,main]
    [[d(111),c,b,a,main],[c,b,a,main],[b,a,main],[a,main],[main]]
    [c,b,a,main]
    [[d(111),c,b,a,main],[c,b,a,main],[b,a,main],[a,main],[main]]
    [b,a,main]
    [[d(111),c,b,a,main],[c,b,a,main],[b,a,main],[a,main],[main]]
    [a,main]
    [[d(111),c,b,a,main],[c,b,a,main],[b,a,main],[a,main],[main]]
    [main]
    File 'z.pl' consulted 86140 bytes 0.002 sec.
    yes
    [main] ?-
