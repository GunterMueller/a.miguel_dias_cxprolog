/*
 *   This file is part of the CxProlog system

 *   README
 *   by A.Miguel Dias - 93/11/17
 *   CITI - Centro de Informatica e Tecnologias da Informacao
 *   Dept. de Informatica, FCT, Universidade Nova de Lisboa.
 *   Copyright (C) 1993, ..., 2001 A.Miguel Dias, CITI, DI/FCT/UNL

 *   CxProlog is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 1, or (at your option)
 *   any later version.

 *   CxProlog is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.

 *   You should have received a copy of the GNU General Public License
 *   along with CxProlog; see the file COPYING.  If not, write to
 *   the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

CxProlog version 0.79

Index:

 - Introduction
 - Limits
 - Builtin Predicates
 - Testing

/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

Introduction

CxProlog is a WAM based Prolog system, extended with some features:
    - threads (Modula-2-like coroutines);
    - units (Modula-2-like modules)
    - contexts (cf. [L.Monteiro, A.Porto: "Contextual Logic Programming",
      in Proc. 6 ICLP, Lisboa, Portugal, MIT Press, 1989])
    - some imperative mechanisms: imperative variables (ivars),
                                  imperative queues,
                                  imperative stacks,
                                  imperative dictionaries

CxProlog is small and manageable, yet reasonably fast.

CxProlog is a compiler but provides an interpreter-like interface.

CxProlog is written in C. CxProlog was tested on the Macintosh (using
the THINKC 5.0 compiler and the MPW development system) and on several
Unix machines using the gcc compiler: i386, R6000, Mips.
It should be compatible with any 32 or 64 bit machine with at least
3 bits available for tags in the data addresses. No customisation of
the source code is necessary, as CxProlog adjusts itself to the
machine where it runs.

The core of the builtin predicates supported by CxProlog are those
described in "Introduction to Logic Programming" by Clocksin, Springer
Verlag.

CxProlog system is experimental software. As yet, there is no support for
it, neither documentation besides this "_README" file.

The main contributors with ideas for improving CxProlog was:
Antonio Porto, Tiago Antao, Rui Marques, Paulo Matos.

Artur Miguel Dias (amd@di.fct.unl.pt)
CITI - Centro de Informatica e Tecnologias da Informacao
Dept. de Informatica, FCT, Universidade Nova de Lisboa
Portugal

/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

Limits

    Static Area: No limit (grows as necessary)
    Local Stack + Global Stack: No limit (grows as necessary)
    Trail: No limit (grows as necessary)
    Max arity of functor or predicate: 64
    Max number of distinct variables in term: No limit
    Max length of n atom: No limit
    Max number of clauses per predicate: No limit
    Max code length of compiled clause: No limit
    Max number of distinct variables in asserted clause: 64
    Max number of simultaneously open streams: 16

/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

Builtin Predicates

This section describes the CxProlog predefined builtin predicates.
Each predicate is introduced using its generic goal template, followed
by a condensed description of its semantics.

Here is an example of a typical goal template:

                             functor(?T,?A,?N).

In each goal template, the symbols preceding the parameters have the
following interpretation:

   +   Input parameter. The actual argument instantiates the parameter.
   -   Output parameter. The actual argument is matched against the
       parameter.
   ?   Input/Output parameter. The actual argument can be used both ways.

Also, in each goal template, the name selected for the parameters reflect
their general types, according to the following table:

   A - atom
   D - dictionary
   F - filename
   K - stack
   L - list
   N - number
   Q - queue
   S - stream
   T - general term
   U - unit designator
   Z - thread

The sophisticated user can add extra builtin predicates and redefine
existing predefined builtin predicates. The subsection "ALTERNATIVE
BOOT FILE", near the end of this section, explains how this is done.

Most of the CxProlog predefined builtin predicates conform to:

    - Clocksin: "Introduction to Logic Programming", Springer Verlag.
    - L.Monteiro, A.Porto: "Contextual Logic Programming",
                in Proc. 6 ICLP, Lisboa, Portugal, MIT Press, 1989.

MISC
~~~~
version             % Show the identification of the current version
                    %   of CxProlog.
show                % Synopsis of the available "show predicates", which
                    %   are predicates that show selected details of
                    %   the CxProlog internal state.
host_speed(-N)      % Evaluates the speed of the host machine. Faster
                    %   machines produce larger numbers. Examples:
                    %     - MacPlus --> 2;
                    %     - Celeron/433 --> 448.

CONTROL
~~~~~~~
+T1,+T2             % Conjunction. Proves T1 and T2.
+T1;+T2             % Disjunction. Proves T1 or T2.
!                   % Cut. When encountered as a goal, it commits the
                    %   predicate where it occurs to the choices made
                    %   since that predicate was last activated. !/0
                    %   works well in the context of:
                    %       call/1, not/1, ->/2, ;/2, ,/2, <>/2, >>/2,
                    %       call_on_empty_context/1
call(+T)            % Proves goal T.
+T                  % Same as call(+T).
not +T              % Goal T is not provable (it fails).
+T1->+T2;+T3        % Conditional goal. If T1 succeeds prove T2; if not,
                    %   prove T3.
+T1->+T2            % Same as (T1->T2;true). But if the "compatible_if_then"
                    %   flag is 'on', it becomes equivalent to
                    %   (T1->T2;false) as in most Prologs.
true                % Succeeds.
fail                % Fails.
false               % Same as fail.
repeat              % Succeeds repeatedly on backtracking.
restart             % Restarts CxProlog execution. The execution stacks are
                    %   cleared, but the internal database remains unchanged.
halt                % Terminates CxProlog execution displaying the message
                    %   "CxProlog halted".
exit                % Exits from CxProlog, displaying no message.
question(+T,+L)     % Implements the top level queries of the predefined
                    %   top level user iteration. Also implements the '?-T'
                    %   questions inside the consult/reconsult predicates.
                    %   This predicate depends on predicate top_call/1.
top_call(+T,+L)     % top_call/1 is specialised in activating goals at
                    %   the top level iteration. Is used by question/2, 
                    %   and should also be used by the user, in case the
                    %   user redefines the top level iteration.
                    %   [There is no harm in using call/1 at the top level,
                    %    but certain CxProlog services are only available
                    %    through top_call/1.]

TERMS
~~~~~
var(+T)             % T is an uninstantiated variable.
nonvar(+T)          % T is an instantiated term.
atom(+T)            % T is an atom.
integer(+T)         % T is an integer number.
float(+T)           % T is a float number.
number(+T)          % T is a number (integer or float).
atomic(+T)          % T is an atom or a number.
functor(?T,?A,?N)   % T is a term with name A and arity N.
arg(+N,+T,-Tn)      % Tn in the Nth argument of term T.
?T =.. ?L           % Univ. L is the list whose head is the atom
                    %   corresponding to the principal functor of T and
                    %   whose tail is the list of arguments of T.
name(?A,?L)         % L is the list of ASCII codes that makes up the
                    %   printed representation of the atom A.
numbervars(+T,+Na,-Nz)
                    % Unifies the variables in T to terms of the form
                    %   '$VAR'(N), with N between Na and Nz-1.
+T1 = +T2           % Unifies T1 with T2.
+T1 \= +T2          % T1 is not unifiable with T2.
findall(+T1,+T2,-L) % L is unified with the list (not ordered an possibly
                    %   containing duplicates) of the instances of template
                    %   T1 for which T2 is provable. All free variable
                    %   (those contained in T2 and not in T1) are
                    %   considered to be existentially quantified.
copy_term(+T1,-T2)  % T2 is a copy of term T1 in which all variables have
                    %   been replaced by new variables occurring nowhere
                    %   else.
copy_term(L,+T1,-T2)% T2 is a copy of term T1 in which all variables in
                    %   list L have been replaced by new variables
                    %   occurring nowhere else. Example:
                    %      copy_term([X,Y],f(A,X,Y),Z) --> Z=f(A,_45,_46).
quote(+A1,-A2)      % Quotes a piece of text.
atom_term(?A,?T)    % Converts between a term T and its textual
                    %    representation A.
atom_termq(?A,?T)   % Variant of atom_term(?A,?T) which quotes atoms where
                    %    necessary so that the conversion is reversible.
app(?L1,?L2,?L3)    % Append lists.
add_pl(+A1,-A2)     % A2 is the concatenation of A1 with '.pl' unless this
                    %   extension is already in A1. Another exception is
                    %   the atom 'user', which remains unchanged.
atoms               % Shows information concerning the CxProlog hash table
                    %   of atoms.
floats              % Shows information concerning the CxProlog hash table
                    %   of very large precision floats.

COMPARING TERMS
~~~~~~~~~~~~~~~
A total ordering, called "standard order" and denoted by @<, is defined
over the set of all prolog terms. Most predicates in this section are
concerned with this ordering.

+T1 == +T2          % T1 and T2 are literally identical.
+T1 \== +T2         % T1 and T2 are not literally identical.
+T1 @< +T2          % T1 is before T2 in the standard order.
+T1 @> +T2          % T1 is before T2 in the standard order.
+T1 @=< +T2         % T1 is not after T2 in the standard order.
+T1 @>= +T2         % T1 is not before T2 in the standard order.
sort(+L1,-L2)       % Quicksorts list L1 into L2. Duplicates are removed.
msort(+L1,-L2)      % Quicksorts list L1 into L2.
keysort(+L1,-L2)    % Quicksorts list L1 into L2. Items of L1 must have
                    %   the form Key-Value.

ARITHMETIC
~~~~~~~~~~
These are the predicates that deal with the evaluation of arithmetic
expressions. At the time of evaluation, each logic variable in an
arithmetic expression is expected to be bound to some number or to
some arithmetic expression.

-N is +Exp          % Evaluates Exp as an arithmetic expression and unifies
                    %   the result with N. The result of the evaluation is
                    %   automatically converted to an integral value
                    %   whenever its decimal part is zero or almost zero.
+T1 =:= +T2         % T1 and T2 evaluate to the same number.
+T1 =\= +T2         % T1 and T2 do not evaluate to the same number.
+T1 < +T2           % The value of T1 is lesser than the value of T2.
+T1 > +T2           % The value of T1 is greater than the value of T2.
+T1 =< +T2          % The value of T1 is not greater than the value of T2.
+T1 >= +T2          % The value of T1 is not less than the value of T2.
succ(?N1,?N2)       % The non-negative integer N2 is the successor of the
                    %   non-negative integer N1.

Syntax of the arithmetic expressions:

Exp ::=
    cputime         heapused        pi             inf
    max_int         min_int         int_size       float_size
    Exp + Exp       Exp - Exp       - Exp
    Exp * Exp       Exp / Exp       Exp mod Exp     Exp ^ Exp
    sqrt(Exp)       exp(Exp)        log(Exp)        log10(Exp)
    Exp >> Exp      Exp << Exp      Exp // Exp      Exp /\ Exp
    Exp \/ Exp      \ Exp           ceil(Exp)       floor(Exp)
    sin(Exp)        cos(Exp)        tan(Exp)        asin(Exp)
    acos(Exp)       atan(Exp)       [Exp]

'inf' is a special number that is larger than any other number.
'inf' stands for "infinite". Here are some of its properties:
      N<inf, for any number N
      -inf<N, for any number N
      1/inf =:= 0
      1/0 =:= inf
      inf/0 =:= inf
      inf + 1 =:= inf
      inf * inf =:= inf
      inf =:= inf

[Exp] is allowed only if the flag 'compatible_strings' is 'on'. For
      example "a" =:= [97] =:= 97.

UNITS/CONTEXTS
~~~~~~~~~~~~~~
In CxProlog, every goal is proved in relation to a CURRENT CONTEXT, which
is a stack of unit designators. We call CURRENT UNIT the unit designated
by the unit designator at the top of the current context. There is no
current unit when the current context is empty. An extra HISTORIC CONTEXT
where entire contexts can be pushed was included for further flexibility.

When a predicate is invoked and, in the current unit, there is no matching
local nor imported definition available, the units below the current unit
are sequentially searched, from top to bottom. If a suitable visible
definition is found then the execution of the predicate proceeds in the
smaller context that results from the initial one by removing all the
unsuccessfully searched units. Otherwise the predicate fails (and produces
an warning if the flag 'undef_warnings' is 'on').

+U>>+T              % Context extension. Proves T with the current context
                    %   temporarily extended with the unit designator U.
+U<>+T              % Context switching. Proves T with the top of the
                    %   current context replaced by the unit designator U.
call_on_empty_context(+T)
                    % Context freeing. Proves T in the empty context.
call_on_context(+L,+T)
                    % Context setting. Proves T in a given context L,
                    %   represented as a list of unit designators.
down(+T)            % Context down. Proves T in with the top of the
                    %   current context popped.
context(-L)         % L is the current context, represented as a list of
                    %   unit designators.
show_context        % Displays the current context on the current output
                    %   stream.
show_context(+S)    % Displays the current context on the output stream S.

>+T                 % Context saving. Proves T in the current context,
                    %   after pushing the current context on the historic
                    %   context.
<+T                 % Context restoring. Proves T in the most recently
                    %   saved context, which is temporarily popped from
                    %   the historic stack.
hcontext(-L)        % L is the current historic context, represented as a
                    %   list of lists of unit designators.
show_hcontext       % Displays the current historic context on the current
                    %   output stream.
show_hcontext(+S)   % Displays the current historic context on the output
                    %   stream S.

create_unit(+USpec) % Creates a new unit, as specified by term USpec.
context_top(-U)     % U is the top of the current context. Note that this
                    %   unit designator designates the current unit.
unit_param(+N,-T)   % T is the value of the Nth parameter of the current
                    %   unit.
unit_arity(-N)      % N is the arity of the current unit.
current_unit(-T)    % Generates (through backtracking) the functors of
                    %   all the existing units.
units               % Shows all the existing units.

check_imports       % Produces warnings concerning the inconsistency of
                    %   the import/visibility declarations. Examples:
                    %   - "Predicate A/N is imported from non-existent
                    %          unit U".
                    %   - "Imported predicate A/N is not visible
                    %          in unit U".
check_missing       % Produces warnings concerning missing predicates,
                    %   invoked in existing code. Sometimes they will be
                    %   legitimate "context dependent predicates". 
                    %   Sometimes they will be genuine mistakes that must
                    %   be corrected.

*** SAMPLING UNIT DEFINITION.
This is a simple sampling unit definition. Notice the visibility
declarations and the import declarations:
-----
unit a(P)
visible [xxx/0, yyy/0, ccc/0].
import vvv/0 from d(222).

xxx :- show_context, writeln('xxx: I am the a/0 version').
ccc :- show_context, xxx.
yyy :- unit_param(1,X), writeln(X).
s:- v := [1,2,Z].
g(X) :- v =: X.
-----

PROGRAM DATA BASE
~~~~~~~~~~~~~~~~~
Some of these predicates allow the program to be modified while running.
Some other predicates allow information about the state of the program
to be gathered.

assert(+T)          % Clause T is asserted at the beginning of the current
                    %   unit. This predicate invokes a fast compiler
                    %   (written in C) that generates code for the
                    %   CxProlog virtual machine.
asserta(+T)         % Same as assert(+T).
assertz(+T)         % Asserts the clause T at the ending of the current
                    %   unit.
clause(+T1,-T2)     % Matches T1 and T2 with the head and body of a clause
                    %   in the current unit. This predicate can be used to
                    %   generate, through backtracking, all the clauses in
                    %   the current unit.
retract(+T)         % Erases from the current unit the first clause
                    %   matching T.
retractall(+T)      % Erases from the current unit all the clauses whose
                    %   heads match T.
abolish(+A,+N)      % Deletes the predicate A/N from the current unit. The
                    %   abolish/2 predicate can also be used to delete
                    %   predicate import declarations.
abolish_builtin(+A,+N)
                    % Deletes the predefined builtin predicate A/N. THIS
                    %   PREDICATE IS ONLY AVAILABLE AT BOOT TIME. It allows
                    %   predefined builtin predicates to be redefined
                    %   at boot time.
current_predicate(-T)
                    % Generates (through backtracking) the functors of all
                    %   predicates in the current unit.
visible_predicate(-T)
                    % Generates (through backtracking) the functors of all
                    %   visible predicates in the current unit.
imported_predicate(-T,-U)
                    % Generates (through backtracking) the functors of all
                    %   imported predicates in the current unit
builtin_predicate(-T)
                    % Generates (through backtracking) the functor of all
                    %   the builtin predicates.
system_predicate(-T)% Same as builtin_predicate/1.
builtins            % Shows all existing builtin predicates.

+T1 :- +T2          % Handy predicate for asserting clauses at the top
                    %   level. Equivalent to assertz((+T1 :- +T2)).
all                 % Lists the contents of all the existing units.
listing             % Lists the contents of current unit, including the
                    %    visibility and the import declarations.
list                % Same as listing.
listing(+A)         % Lists all the predicates named A in the current unit.
listing(+A/+N)      % Lists the clauses of predicate A/N, in the current
                    %   unit.
code(+A)            % Displays the virtual machine code for all predicates
                    %   named A in the current unit.
code(+A/+N)         % Displays the virtual machine code for the predicate
                    %   A/N in the current unit.
statistics          % Shows the space currently used in the various data
                    %   areas of CxProlog and also the running time since
                    %   startup.
silent_consult(+F)  % Consults the file F producing no information of its
                    %   own. Commands of the form ':-T' and questions of
                    %   the form '?-T' are supported.
silent_reconsult(+F)% Reconsults the file F producing no information of its
                    %   own. Commands of the form ':-T' and questions of
                    %   the form '?-T' are supported.
consult(+F)         % Consults the file specified by F (using
                    %   silent_consult/1), writing a few statistics
                    %   afterwards.
reconsult(+F)       % Reconsults the file specified by F (using
                    %   silent_reconsult/1), writing a few statistics
                    %   afterwards.
[+F1,...,+Fn]       % Shorthand for consulting or reconsulting a list of
                    %   files. A filename Fi may optionally be preceded by
                    %   the operator '-' to indicate that file should
                    %   be reconsulted instead of consulted.
                    %   Example:[a,-b].

OPERATORS
~~~~~~~~~
op(+Prec,+Type,+Name)
                    % Declares a operator named Name of type Type and
                    %   precedence Prec. Name can be a single operator
                    %   name or a list of operator names. Type is one of
                    %   the following atoms: fx, fy, xf, yf, xfx, xfy, yfx,
                    %   yfy. Prec is one integer in the range 1..1200,
                    %   higher values indicating lower precedence.
current_op(?Prec,?Type,?Name)
                    % Provides read access to the internal operator table.
ops                 % Shows details about the currently defined operators.
reset_ops           % Resets all the operators to their initial state

INPUT/OUTPUT - DEC-10 Prolog compatibility streams
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Predicates see/1 and tell/1 take filenames as arguments and
predicates seeing/1 and telling/1 return filenames. The remaining
predicates act over the current input or the current output streams.

see(+F)             % The file F is opened (if not already open) and is
                    %   made the current input stream.
seeing(-F)          % Gets the filename of the current input stream.
seen                % Closes the current input stream.
read(-T)            % Reads the next term from the current input stream. At
                    %   end of file, the atom 'end_of_file' is returned.
                    %   (The names of the variables in the term T can be
                    %   gathered using varnames/1.)
varnames(-L)        % L is a list of pairs Var=Name, telling the names of
                    %   all the variables in the last term returned by
                    %   read/1 or read/2.
read_tokens(-L)     % Reads an entire line of text as a list of tokens
                    %   [token = atomic lexical element]. If the line is
                    %   empty then the empty list is returned. At
                    %   end of file, the atom 'end_of_file' is returned.
get0(-N)            % Gets the ASCII code of the next char from the current
                    %   input stream. At end of file, the code 26 is
                    %   returned.
get(-N)             % Gets the ASCII code of the next printing char from
                    %   the current input stream. End of file is denoted
                    %   by code 26.
get_line(-A)        % Reads an entire line of text as an atom. At end of
                    %   file returns the integer 26.
peek0(-N)           % Similar to get0(-N), but it does not consume the
                    %   returned char.
peek(-N)            % Similar to get(-N),  but it does not consume the
                    %   returned char.
skip(+N)            % Skips over chars in the current input stream until
                    %   the first occurrence of the char with code N.

tell(+F)            % The file F is opened (if not already open) and made
                    %   the current output stream.
telling(-F)         % Gets the filename of the current output stream.
told                % Closes the current output stream.
flush               % Flushes the buffer of the current output stream.
write(+T)           % Writes the term T to the current output stream.
writeln(+T)         % Variant of write(+T) which outputs an extra
                    %   newline char.
writeq(+T)          % Variant of write(+T) which quotes atoms where
                    %    necessary so that read/1 could read the term back.
writeqln(+T)        % Variant of writeq(+T) which outputs an extra
                    %   newline char.
print(+T)           % For now, equivalent to write/1.
display(+T)         % Writes term to stream user_output, ignoring operators.
displayln(+T)       % Variant of display(+T) which outputs an extra
                    %   newline char.
put(+N)             % Writes the char with code N to the current output
                    %   stream.
nl                  % Writes a newline to the current output stream.
tab(+N)             % Writes N spaces to the current output stream.
write_depth(+N1,+N2)% Sets the maximum term depth and the maximum list
                    %   length used by predicates write/1, write/2, etc.
                    %   0 (zero) means no limit. The initial values are
                    %   respectively 30 and 999.

INPUT/OUTPUT - Streams
~~~~~~~~~~~~~~~~~~~~~~
On the following predicates, S stands for a stream (a new kind of
primitive type), or for an ivar bound to a queue.

Most of the predicates of this section require an explicit stream argument.

The predefined streams are denoted by 'user_input', 'user_output',
'user_error' and 'user'. 'user' represents 'user_input' or 'user_output',
depending on the context.

stream(+S)          % S is a valid active stream.
open(+F,+M,-S)      % The file specified by F is opened as a stream (if not
                    %   already open) and the corresponding stream object
                    %   is returned in S. Mode M is one of following atoms:
                    %   'read', 'write', 'append'.
close(+S)           % Closes the stream S.

set_input(+S)       % Makes stream S the current input stream.
current_input(-S)   % Gets the current input stream.
read(+S,-T)         % Reads term from the input stream S. At end of file,
                    %   the atom 'end_of_file' is returned. (The names of
                    %   all the vars in the term T can be gathered using
                    %   varnames/1.) 
read_tokens(+S,-L)  % Reads from S an entire line of text as a list of
                    %   tokens [token = atomic lexical element]. If the
                    %   line is empty then the empty list is returned. At
                    %   end of file, the atom 'end_of_file' is returned.
get0(+S,-N)         % Gets the ASCII code of the next char from
                    %   stream S. At end of file, the code 26 is returned.
get(+S,-N)          % Gets the ASCII code of the next printing char from S.
                    %   End of file is denoted by code 26.
get_line(+S,-A)     % Reads an entire line as an atom. At end of file
                    %   returns the integer 26.
peek0(+S,-N)        % Similar to get0(+S,-N), but it does not consume the
                    %   returned char.
peek(+S,-N)         % Similar to get(+S,-N),  but it does not consume the
                    %   returned char.
skip(+S,+N)         % Skips over chars in the current input stream until
                    %   the first occurrence of the char with code N.

set_output(+S)      % Makes stream S the current output stream.
current_output(-S)  % Gets the current output stream.
flush(+S)           % Flushes the buffer of the current output stream.
write(+S,+T)        % Writes the term T to the output stream S.
writeln(+S,+T)      % Variant of write(+S,+T) which outputs an extra
                    %   newline char.
writeq(+S,+T)       % Variant of write(+S,+T) which quotes atoms where
                    %    necessary) so that read/2 could read the term back.
writeqln(+S,+T)     % Variant of writeq(+S,+T) which outputs an extra
                    %   newline char.
print(+S,+T)        % For now, equivalent to write/2.
put(+S,+N)          % Writes the char with code N to the output stream S.
nl(+S)              % Writes a newline to the output stream S.
tab(+S,+N)          % Writes N spaces to the output stream S.
streams             % Shows details about all the currently open streams.

OS & FILE SYS
~~~~~~~~~~~~~
These predicates provide access operating systems services.

unix_arg(+A,-A)     % Gets individual command line arguments.
                    %   Example: unix_arg('-boot',X)
unix_args(-L)       % Gets entire command line as a list of atoms.
                    %   Example: unix_args(X)
unix_env(+A,-A)     % Accesses unix environment variables.
                    %   Example: unix_env('PATH',X)
unix_run(+A,-N)     % Runs unix command A. N is the result code
                    %   returned by the command.
file_exists(+F)     % Checks if the file specified by the filename F can
                    %   be opened for reading.

FLAGS
~~~~~
"The flags" are some internal system flags which allows certain aspects of
the behaviour of CxProlog to be modified. 

flag(+A,-T)         % Queries the value of flag A. Possible values are
                    %    'on', 'off' or an integer value depending on
                    %    the flag.
flag(+A,-To,-Tn)    % Changes the value of flag A. The old value of A is
                    %    To and the new value is Tn. Possible values are
                    %    'on', 'off' or an integer value depending on
                    %    the flag.
flags               % Shows the current status of all CxProlog flags.

Description of the flags:

debugging           - If 'on', allows the user to activate trace mode,
                        either by using the CTRL-C interrupt or by
                        turning 'on' the 'trace' flag. If 'off' the trace
                        mode can never become active. [As yet, the
                        included debugger is rudimentary as only the
                        "call port" is shown.]  DEFAULT=on.
trace               - If 'on', the trace mode becomes active. This flag
                        can be turned 'on' only in case the 'debugging'
                        flag is 'on'. DEFAULT=off.
fail_on_error       - If 'on', every runtime error generates "failure"
                        instead of "restart". In this case, the error
                        message is silently appended to the queue stored
                        in the predefined ivar 'error'. DEFAULT=off.
compatible_if_then  - If 'on', (T1->T2) becomes equivalent to (T1->T2;false)
                        as in most Prologs. If 'off', (T1->T2) becomes
                        equivalent to (T1->T2;true), which is more
                        sound logically. DEFAULT=on.
compatible_strings  - If 'on', any double-quoted literal, like "...",
                        represents a list of ascii codes (which, sometimes,
                        can also be a valid evaluable expression
                        -- see is/2). If 'off', a double-quoted literal
                        is interpreted as an application of functor '""'/1.
                        Example: "12.3" --> '""'(12.3).
bar_is_semicolon    - If 'on', the atom '|' is automatically translated
                        to the atom ';' (except in contexts where '|'
                        is denoting "the reminder of a list"). If 'off' no
                        translation is performed. DEFAULT=on.
keep_source         - If 'on', the clauses will be internally stored in
                        double format: "compiled format" and "source
                        format". This is redundant but predicates
                        clause/2, retract/1 and listing/1 only work with
                        predicates asserted at a time this flag is 'on'.
                        Setting this flag to 'off' saves around 40% of
                        database space (in subsequent asserts or consults).
                        DEFAULT=on.
undef_warnings      - If 'on', a warning is issued whenever an undefined
                        predicate is invoked. Useful for debugging.
                        DEFAULT=on.
memory_warnings     - If 'on', a warning message is issued whenever an
                        internal "elastic buffer" automatically grows.
                        Useful to be aware of the rate of memory
                        consumption. DEFAULT=on.
garbage_collection  - Controls whether the garbage collector of atoms
                        is active or not. DEFAULT=on.
index_params        - States how many parameters should be used in
                        building predicate indexes. Allowed range is
                        0..3, 0 meaning no predicate indexing
                        is required. DEFAULT=1.
float_display_precision - Controls how floats are displayed.
                        If > 0, they are displayed with at least the
                        indicated number of significant digits and
                        using either decimal notation or scientific
                        notation, whichever is shorter.
                        If <= 0, they are displayed with exactly the
                        indicated number of decimal places and
                        using decimal notation. DEFAULT=6.

IMPERATIVE VARIABLES (IVARS)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
An "ivar" is a special name that can be freely bound/rebound to different
prolog terms using the "assignment operator" :=/2. The effects of the
assignment operator are not automatically reversed on backtracking.

CxProlog predefines some ivars: 'user_input', 'user_output', 'user_error',
'user', 'errors', etc.

ivar(+A)            % A is an existing ivar.
+A := +T            % Sets ivar A to T. The ivar A is automatically 
                    %   created if necessary. Always succeeds.
+A =: -T            % Gets the current value of ivar A. Fails in case
                    %   A does not exist.
+A ?:= +T           % Creates and sets ivar A to T only if A does not
                    %   exist already. Nothing is done if A already
                    %   exists. Always succeeds.
+A #:= +T           % Sets the ivar A to T and makes it a CONSTANT. The
                    %   ivar A is automatically created if it does not
                    %   exist already.
ivar_delete(+A)     % Deletes the ivar A, if it exists.
current_ivar(-A,-T) % Generates (through backtracking)  all the existing
                    %    ivars and the corresponding values.
ivars               % Shows all the existing ivars and corresponding values.

IMPERATIVE QUEUES
~~~~~~~~~~~~~~~~~
On the following predicates, Q stands for a queue (a new kind of primitive
type) or for an ivar bound to a queue.

A queue can store terms of any kind: for example it can mix integers,
queues and dictionaries. The queues are "imperative" in the sense that
the effects of the queue operations are not automatically undone
on backtracking.

queue(+Q)           % Q is a queue.
queue_new(-Q)       % Creates a new queue Q.
queue_clear(+Q)     % Clears the queue Q.
queue_delete(+Q)    % Deletes the queue Q.
queue_put(+Q,+T)    % Puts the term T at the end of the queue Q.
queue_get(+Q,-T)    % Gets the term T from the front of the queue Q.
queue_peek(+Q,-T)   % Examines the front of the queue Q.
queue_write(+Q)     % Writes the queue Q to the current output stream.
queue_write(+S,+Q)  % Writes the queue Q to the stream S.
queue_as_list(+Q,-L)% Converts the queue Q to a list L of terms.
current_queue(-Q)   % Generates (through backtracking) all the
                    %   existing queues.
queues              % Shows all existing queues.

IMPERATIVE STACKS
~~~~~~~~~~~~~~~~~
On the following predicates, K stands for a stack (a new kind of primitive
type) or for an ivar bound to a stack.

A stack can store terms of any kind: for example it can mix integers,
queues and dictionaries. The stacks are "imperative" in the sense that
the effects of the stack operations are not automatically undone on
backtracking.

stack(+K)           % K is a stack.
stack_new(-K)       % Creates a new stack K.
stack_clear(+K)     % Clears the stack K.
stack_delete(+K)    % Deletes the stack K.
stack_push(+K,+T)   % Pushes the term T on the stack K.
stack_pop(+K,-T)    % Pops term T from the stack K.
stack_top(+K,-T)    % Examines the top of the stack K.
stack_write(+K)     % Writes the stack K to the current output stream.
stack_write(+S,+K)  % Writes the stack K to the stream S.
stack_as_list(+K,-L)% Converts the stack K to a list L of terms.
current_stack(-K)   % Generates (through backtracking) all the
                    %   existing stacks.
stacks              % Shows all existing stacks.

IMPERATIVE DICTIONARIES
~~~~~~~~~~~~~~~~~~~~~~~
On the following predicates, D stands for a dict (a new kind of primitive
type) or for an ivar bound to a dict.

A stack can store terms of any kind: for example it can mix integers,
queues and dictionaries. The access key can also be a term of any kind.
The dicts are "imperative" in the sense that the effects of the dicts
operations are not automatically undone on backtracking.

dict(+D)            % D is a dictionary.
dict_new(-D)        % Creates a new dictionary D.
dict_clear(+D)      % Clears the dict D.
dict_delete(+D)     % Deletes the dict D.
dict_set(+D,+Key,+T)% Associates the term T with the key Key in the
                    %   dictionary D.
dict_get(+D,+Key,-T)% Gets T associated with Key in dictionary D.
dict_delete_item(+D,+Key)
                    % Deletes the key Key from the dictionary D.
dict_write(+D)      % Writes the dict D to the current output stream.
dict_write(+S,+D)   % Writes the dict D to the stream S.
dict_as_list(+D,-L) % Converts the dictionary D to a list L of K-T pairs.
current_dict(-D)    % Generates (through backtracking) all the existing
                    %   dicts.
dicts               % Shows all existing dictionaries.

HANDLING TRANSIENT TEXT
~~~~~~~~~~~~~~~~~~~~~~~
In CxProlog, the recommended way of dealing with transient text is
through atoms, with the help of predicates get_line/1, get_line/2,
concat/2 and slice/4. These predicates are very flexible and CxProlog
includes a garbage collector of atoms that safely recycles again
and again the space taken by transient text.

slice(+A,+Na,+Nb,-Asub)
                    % Asub is the subatom of atom A that includes the
                    %   characters of A between offsets Na and Nb. These
                    %   offsets are relative to the beginning of A, if
                    %   they are both positive, and are relative to the
                    %   ending of A, if they are both negative.
                    %   Examples:
                    %      slice('ABC',1,1,AS) --> As='A'
                    %      slice('ABC',-2,-1,AS) --> As='BC'.
concat(+L,-A)       % Concatenates all the elements of input list L into
                    %   atom A. The input list L may contain atoms, ints,
                    %   floats and lists. This concatenation is
                    %   recursively applied to all the sublists in L.
                    %   This is to say that the whole list is flattened
                    %   to a single atom. The concat/2 operation
                    %   is performed in a single step so that no
                    %   intermediate garbage is generated. Example:
                    %   ?- concat(['ole ',34.5e-23,z,[[a]]],X), write(X).
                    %   ole 3.45e-22za
                    %   X='ole 3.45e-22za'
-A === +L           % Same as concat(+L,-A). Note that ===/2 resembles
                    %   an assignment operator, and this is why the
                    %   order of parameters was reversed.

THREADS (coroutines)
~~~~~~~~~~~~~~~~~~~~
On the following predicates, Z stands for a thread (a new kind of
primitive type) or for an ivar bound to a thread.

The threads are organised in TREE. Killing a thread also kills all
its descendants

thread_new(-Z, +Goal, +RestartGoal)
                    % Creates a new thread Z. Goal is the startup goal.
                    %   RestartGoal is a goal that is activated
                    %   in case of error or explicit restart/0 call.
thread_transfer(+Z,-A)
                    % Transfers control to the thread Z. Possible results
                    %   are: 'going','completed','failed','killed','error'.
thread_kill(+Z)     % Kills the thread Z.
active_thread(-Z)   % Z is the active thread.
active_thread_completed
                    % Finishes the active thread making it return
                    %   'completed'.
active_thread_failed
                    % Finishes the active thread making it return 'failed'.

CUSTOMISE THE LANGUAGE - ALTERNATIVE BOOT FILES
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Using the conventional command line argument '-boot', the user may
specify his own alternative boot file. Instead, an alternative boot
file can be specified through the invocation of the c-function
'SpecifyBootFile(.)' from inside c-function 'YourPrologue()'
(as in: SpecifyBootFile("MyBootFile.pl").

Through the definition of a boot file, the user is able to customise
aspects of the language. Specifically, the user can:

   - Replace the provided default top level user iteration;
   - Add extra builtin predicates written in Prolog: all predicates
     defined inside the boot file, or loaded from commands inside
     the boot file, are taken as builtin;
   - Redefine predefined builtin predicates: simply, don't forget to
     issue an abolish_builtin/2 command, prior to each such redefinition.

Any alternative boot file MUST define the following two predicates:

'$cxprolog_startup' % Startup predicate where the top level iteration
                    %   is activated. (Non-builtin predicates are
                    %   also usually loaded from here, because when
                    %   '$cxprolog_startup' is activated, the boot
                    %   process has already finished.)
'$cxprolog_restart' % Restart predicate which is activated after
                    %   an explicit restart/0 call, after an error,
                    %   or after a CNTL-C interrupt. The top
                    %   level iteration should be reactivated here.

FURTHERMORE, at the top level iteration, all goals MUST be activated
through the high level predicate question/2, or through the lower level
predicate top_call/1.

Nothing else is required or assumed by CxProlog, concerning
alternative boot files.

The accompanying file "CxBoot.pl" serves as an example of a simple boot
file. Actually, the contents of this file match the defaults used by
CxProlog when no boot file is provided (see DEFAULT BOOT).

DEFAULT BOOT
~~~~~~~~~~~~
Missing the conventional command line argument '-boot' (or a
'SpecifyBootFile' function invocation) CxProlog does not load any
boot file whatsoever. Instead, it installs a default top level
interaction oriented toward program development.

There are four minor builtin predicates introduced in the default boot:

push +U             % Pushes the unit designator U on top of current
                    %   context, therefore changing the current unit
                    %   used by the top level iteration.
pop                 % Pops the current context, therefore restoring the
                    %   previous current unit used by the top level
                    %   iteration
trace               % Turns trace mode 'on'. As yet, the included
                    %   debugger is rudimentary as only the "call
                    %   port" is shown.
notrace             % Turns trace mode 'off'. 

/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

Testing

In order to test CxProlog in your machine, consult the file 'z.pl'.
Assuming you are using the default boot, the output should resemble
the following:

[main] ?- [z].
File zbm.pl consulted 4748 bytes 0.00061035 sec.
File zstr_io.pl consulted 27260 bytes 0.030366 sec.
File ztokens.pl consulted 33336 bytes 0.041221 sec.
File zutils.pl consulted 11564 bytes 0.01177 sec.
6.2337e+05 lips for 50 iterations taking 0.039268 secs (0.039268-0)
6.5643e+05 lips for 50 iterations taking 0.037314 secs (0.037314-0)
a(_215,[we,45,_664])
unit main
unit a
unit b
unit c
unit d(P)
File zu.pl consulted 3596 bytes 0.0037994 sec.
[c,b,a,main]
[c,b,a,main]
xxx: I am the c/0 version
[c,b,a,main]
[b,a,main]
xxx: I am the b/0 version
[c,b,a,main]
[b,a,main]
[b,a,main]
xxx: I am the b/0 version
[b,a,main]
[a,main]
[a,main]
xxx: I am the a/0 version
[c,b,a,main]
[d(222),b,a,main]
[yyy: I am the d/1 version,222]
File z.pl consulted 82828 bytes 0.16475 sec.
yes

/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
- END -- END -- END -- END -- END -- END -- END -- END -- END -- END --
/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/


PRIVATE AREA: please ignore

*Index rules:
When first called, any predicate is provisorily considered a static
predicate and its index is built.
If a predicate is changed afterwards (using retract or assert),
the predicate is then definitely considered as dynamic and its index
removed. A dynamic predicate has no index because it would be
inefficient to keep rebuilding the index again and again.

*Permanent/temporary atoms rules:
Atoms occurring in clauses are internally kept as 'permanent atoms'.
Ivar names are internally kept as 'permanent atoms'.
Unit names are internally kept as 'permanent atoms'.
Operator names are internally kept as 'permanent atoms'.
Predicate names are internally kept as 'permanent atoms'.
All other atoms are kept as 'temporary atoms'.

There is a garbage collector of temporary atoms that safely recycles
again and again the space taken by transient text.

TODO:
file sys
more flexible i/o DONE
more flexible read/write, choosing channel and language
tuples?
elastic buffers
compile contexts
fix operators
debugger
optimisation
garbage collection
garbage collector of clauses
manual
lang type
recursivity elimination
remove texts and replace then by a garbage collector of atoms DONE
Introduce a Float hash table DONE
no_strings flag affects is.

Pathologic Overflows:
    buffer:  X = f(X,X).
    local stack: a:-a. a:-a. a.


        CheckGlobalStackOverflow() ;
            if( CodeOverflow() ) return nil ;
        CheckLocalStackOverflow() ; }
            if( nRecs >= nRecsMax ) Error("Clause too big") ;



        Error("Too many variables in term") ;
        Error("Too many files open, openning '%s'", name) ;
        Error("Too many variables in clause") ;
